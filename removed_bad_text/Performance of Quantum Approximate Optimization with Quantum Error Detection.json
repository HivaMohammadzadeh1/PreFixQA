[
    {
        "id_": "8f7882b8-3561-4bb7-a876-f9d66a5255f8",
        "text": "# I. INTRODUCTION\n\nQuantum computers are poised to deliver algorithmic speedups for a broad range of application in science and industry[1–3]. However, realizing these speedups requires overcoming the challenge presented by the noise which limits the computational power of today’s quantum devices. Error correction[4] provides a scalable path to fault-tolerance and has shown significant progress in hardware recently[5–14]. Nonetheless, quantum error-correction imposes large overheads, making it challenging to execute even small-scale applications fully fault-tolerantly. As a result, fully fault-tolerant demonstrations of quantum algorithms for practical applications have been out of reach of experiment, despite immense progress in implementation and benchmarking of algorithmic components, such as preparation of magic states[15], one-bit addition[16] and quantum Fourier transform[17].\n\nQuantum error detection (QED) codes provide an opportunity for partially fault-tolerant implementation of algorithms in the near term[9, 10, 18–22]. While non-scalable, they can still deliver improved algorithmic performance beyond what is possible without protecting against noise[23–26]. The protection offered by QED codes opens an opportunity to use quantum computers to study the performance of quantum algorithms for sizes and noise rates beyond classical simulation.\n\nThe recently proposed [[k + 2, k, 2]] “Iceberg” QED code[18] is particularly suitable for near-term algorithms due to its ability to encode expressive circuits, using a universal set of local and global logical rotations, with a low overhead. The Iceberg code has been demonstrated to improve the fidelity of random circuits with up to 8 logical qubits and 1323 physical two-qubit gates[18], the performance of quantum phase estimation with up to 4 logical qubits and 920 two-qubit gates[25], and the fidelity of ground state preparation with probabilistic imaginary-time evolution with 4 logical qubits and up to 906 two-qubit gates[26]. While not fully fault-tolerant, these experiments provided preliminary evidence that for circuits with small numbers of qubits the Iceberg code can improve algorithmic performance.\n\nQuantum Approximate Optimization Algorithm (QAOA)[27, 28] is a quantum optimization heuristic applicable to a broad range of combinatorial optimization problems in finance and other industries[29–32]. QAOA has been shown to provide a quantum algorithmic speedup over state-of-the-art solvers for some problems[33, 34], motivating its implementation on hardware. While relatively low resource requirements enabled QAOA execution on non-error-corrected hardware[35–42], realizing the speedup offered by QAOA is widely believed to require fault tolerance[43, 44]. We remark that both quantum hardware performance and the impact of quantum noise on QAOA have been subject of extensive interest[45–52].\n\nWe demonstrate a partially fault-tolerant implementation of QAOA applied to the MaxCut problem on Quantinuum H2-1 trapped-ion quantum computer[54] with the Iceberg code. At the time of experiments, the H2-1 device had 32 all-to-all connected qubits and 99.8% two-qubit gate fidelity[38]. We execute circuits with up to 24 logical qubits encoded into up to 26 physical."
    },
    {
        "id_": "59f35ea5-9b53-43b6-9a9f-a3b3f7f42aa1",
        "text": "# 2"
    },
    {
        "id_": "35c804c3-d69c-477c-955a-a45da69f4e92",
        "text": "# A\n\nDecode"
    },
    {
        "id_": "2cc2b1fd-e43b-4bd3-918f-c8de6feaa230",
        "text": "# B\n\nPCS H2-1E\n\nLogical fidelity\n\n0.4\n\nIceberg H2-1E\n\nUnencoded H2-1E\n\nLogical QAOA initial\n\nk + 20.3\n\nstate preparation\n\nPost-\n\n|0⟩\n\n… selected\n\n0.2\n\nLogical QAOA samples\n\ngates\n\n2\n\n2\n\n2\n\n2\n\n0.1\n\n|0⟩\n\n|0⟩\n\nIf %! = −1\n\nDiscard\n\n2\n\n4\n\n6\n\n8\n\nSyndrome measurement\n\nIf any readout is 1"
    },
    {
        "id_": "038d6dab-da1e-472d-957f-f9531dae5a3f",
        "text": "# C\n\n0.95"
    },
    {
        "id_": "d846cb3d-dfa9-4973-8abe-e4972d72c493",
        "text": "# D\n\nLogical QAOA\n\nUnencoded H2-1\n\ngates\n\n0.6\n\nIceberg H2-1\n\n0.85\n\n0.90\n\n0.4\n\nSyndrome\n\nmeasurement Probability\n\n0.85\n\nUnencoded H2-1\n\nIceberg H2-1\n\n0.2\n\n0.75\n\n0.00.6\n\nLogical QAOA\n\n16 18 20 22 24\n\n0.7\n\n0.8\n\n0.9\n\n1.0\n\n2\n\n4\n\n6\n\n8\n\ngates k\n\nApproximation ratio"
    },
    {
        "id_": "1d91c204-7fa1-42dd-bb6e-e22da1415dcd",
        "text": "# syndrome measurements"
    },
    {
        "id_": "796581c4-c95b-42f7-aa06-abad3a0ccae1",
        "text": "# Final measurement\n\nFIG. 1. Motivation: Iceberg code is a performant method for error detection in the near-term.\n\nA Iceberg code detects errors that occur in execution of an k-qubit circuit by encoding it in (k + 2) physical qubits.\n\nB Shots containing a detected error are discarded, resulting in a post-selection overhead.\n\nC Performance of QAOA with and without the Iceberg code on the Quantinuum H2-1 quantum computer. Here, the logical fidelity, defined in Eq. (17), directly indicates the approximation ratio. The Iceberg code improves performance on small problems, while being detrimental on larger ones.\n\nD An example of measured samples with and without the Iceberg code. After detecting the errors, the probability of the higher energy states is amplified, reflecting the approximation to the noiseless QAOA performance.\n\nE Iceberg code performs better than other commonly-used techniques for error mitigation in QAOA circuits like Pauli Check Sandwiching (PCS) [53]. Error bars show the standard errors.\n\nLogical fidelity\n\nPost-selection rate\n\nqubits using up to 813 physical two-qubit gates and ob-\n\nbe used to predict the performance of the Iceberg code\n\non future improved hardware. We demonstrate condi-\n\ntions on effective error rates for QAOA to outperform\n\nthe Goemans-Williamson (GW) [57] algorithm on small\n\ngraphs. However, we also observe that beyond 20\n\nlogical qubits, Iceberg code does not yield an improved\n\nalgorithmic performance. To the best of our knowledge,\n\nthese experiments are the largest evaluation of Iceberg\n\ncode and the largest QED-encoded application demon-\n\nstration in terms of the number of logical qubits to date."
    },
    {
        "id_": "a23ca9c3-978a-49f2-929b-584555d44b16",
        "text": "# II. BACKGROUND\n\nTo understand the protection capability of the Iceberg\n\ncode, we propose a model that predicts the code perfor-\n\nmance. The model efficiently constructs an analytical es-\n\ntimation of the logical fidelity and post-selection rate as a\n\nfunction of the circuit size and three error rates related to\n\nthe noise produced by two-qubit physical gates. We cal-\n\nibrate the model by simulating a large set of QAOA cir-\n\ncuits of varying sizes with and without the Iceberg code\n\nin the emulator [8, 55, 56] of the H2-1 quantum computer.\n\nThe calibrated model is then used it to characterize the\n\nregimes in which the Iceberg code improves the algorith-\n\nmic performance of QAOA. Specifically, we identify the\n\nranges for the number of logical qubits, QAOA depth,\n\nand the number of syndrome measurements for which\n\nIceberg code is beneficial.\n\nFurthermore, our model can generalize to any optimiza-\n\ntion problem, in this paper we focus on the MaxCut prob-\n\nlem as a commonly-studied benchmark problem.\n\nGiven a graph G(k, E) with k vertices and set of edges\n\nE, the MaxCut problem consists in finding a cut that\n\npartitions the vertices into two sets that maximise the\n\nnumber of edges between them. Cuts can be represented\n\nby strings z of k bits with value z i = ±1 if vertex\n\ni is in one set or the other. The MaxCut objective function can\n\nbe written as f (z) = ∑(i,j)↑E (1 → z z j ).\n\nOn qubits, the MaxCut problem is equivalent to find-\n\ning the ground state of the following k-qubit Hamiltonian."
    },
    {
        "id_": "b610f757-c652-448b-ad38-484016d925ee",
        "text": "# A. Quantum Approximate Optimization Algorithm\n\nQAOA is a quantum algorithm for combinatorial optimization. It solves optimization problems by preparing quantum state using a sequence of ω layers of alternating cost Hamiltonian and mixing Hamiltonian operators, parameterized by vectors ω and ε respectively.\n\n|ϑ↑ = e ↓iω M e ↓iε ω H · · · e ↓iω 1 M e ↓iε 1 H |ϑ 0 ↑ ω (2)\n\nThe parameters ω and ε are chosen such that the measurement outcomes of |ϑ↑ correspond to high-quality solutions of the optimization problem with high probability. In this paper, we take the initial state |ϑ 0 ↑ = |+↑ ↔k as the equal superposition of all possible candidate solutions, and the mixing Hamiltonian as a summation of all single-qubit Pauli-X operator M = ∑ n=1 X . i i\n\nDenoting the value of optimal cut by f max, we can quantify how well QAOA with state |ϑ↑ solves the Max-Cut problem by computing the approximation ratio:\n\nε(ϑ) = |E| → ↔ϑ|H|ϑ↑. (3)\n\nRecent progress in parameter setting heuristics has considerably advanced the execution of QAOA in the early fault-tolerant era [42, 58], with good parameter choices available for many problems. A set of parameters that leads to good approximation ratios was proposed in [59] for the MaxCut problems on regular graphs that we solve in this work. Throughout our paper we use these “fixed angles” to set QAOA parameters in the experiments."
    },
    {
        "id_": "d9a1f81e-8a03-4bc5-8272-22fd4d970785",
        "text": "# B. Iceberg Code\n\nThe Iceberg code protects k (even) logical qubits with n = k + 2 physical qubits and two ancillary qubits. We label the physical qubits as {t, 1, 2, . . . , k, b}, where the two additional qubits are called top t and bottom b for convenience. The two code stabilizers and the logical gates of the QAOA circuit are implemented as the physical gates:\n\nexp(→iϑ Xi ¯ ) = exp(→iϑX X i ), t (8)\n\nexp(→iϖ Zi ¯¯ Z j ) = exp(→iϖZ Z j ). i (9)\n\nIn Quantinuum devices, these physical gates are implemented by just one native two-qubit gate exp(→iϱZ Z j )i and various single-qubit Clifford gates.\n\nAs depicted in Fig. 1A, the Iceberg code employs an initialization block to prepare the initial QAOA state | + ¯↑ ↔n in the common +1 eigenspace of the stabilizers. The logical QAOA gates in Eqs. (8) and (9) are then implemented in blocks, interleaved with syndrome measurement blocks until the QAOA circuit is complete. These syndrome measurement blocks measure the stabilizers regularly across the circuit to prevent the accumulation of noise. The final measurement block measures the stabilizers as well as the k data qubits. The precise form of these blocks is depicted in Appendix A. Accepted samples can be decoded by a classical post-processing and serve as candidate solutions for the problem.\n\nTo detect these errors, the fault-tolerant initialization, syndrome measurement and final measurement blocks employ two ancillas. In the absence of noise, the state remains purely in the +1 eigenspace of the stabilizers during the entire circuit execution and ancillas always output a +1 when measured. The final measurement block additionally measures the stabilizer S Z, which is also expected to be measured as +1 in the absence of noise. Therefore, a →1 output in any of them signals the presence of an error caused by noise, and the circuit execution is discarded.\n\nThe fault-tolerant design of the initialization, syndrome measurement and final measurement blocks ensures that no single faulty component in these blocks (like a two-qubit gate) can cause a logical error. In contrast, our logical gates, despite being natural for the hardware, are not fault-tolerant, as some errors in their physical implementation cannot be detected. We nevertheless show in Sec. III B 2 that undetectable errors are rare, rendering the QAOA protection of the Iceberg code effectively fully fault-tolerant."
    },
    {
        "id_": "5c76900e-f973-44c8-93c0-d24bb011323c",
        "text": "# III. RESULTS\n\nWe now present our results. First, we summarize the results obtained on the hardware. Then, we discuss the model fitting results and the performance predictions on future hardware. The H-series emulators [8, 55, 56] we use perform a state-vector simulation where noise is randomly sampled following realistic noise models and then inserted into the circuit. Currently, the most influential noise channels are gate errors and single-qubit coherent dephasing from memory errors. The performance gap between the hardware and emulator experiments is discussed in Appendix B for completeness."
    },
    {
        "id_": "586b01af-3453-4dda-99e7-82125afd565d",
        "text": "# A. Iceberg code protection of QAOA on hardware\n\nThe performance of the Iceberg code with QAOA on 3-regular graph MaxCut on the Quantinuum H2-1 quantum computer [54] is shown in Fig. 1C. The logical fidelity reported in this figure is estimated from the average energy measured experimentally by assuming a global white noise model distribution, as described in Sec. V C. We fix the QAOA depth to ω = 10 and vary the number of logical qubits k, randomly selecting one MaxCut graph instance per k. For each problem we run QAOA unencoded and QAOA protected by the Iceberg code with three intermediate syndrome measurements. Throughout this paper, the final measurement is counted as a syndrome measurement, so in the previous experiment we say that four syndrome measurements are used. The Iceberg data has larger error bars due to the smaller number of post-selected samples.\n\nThe histogram in Fig. 1D reports the hardware shots of several Iceberg and unencoded QAOA circuits for k = 16. After post-selection, the output distribution has higher weight on bitstrings with higher approximation ratio, as expected from a better protection against noise.\n\nWe compare the performance with that of the Pauli check sandwiching (PCS) [53, 60], an error detection scheme with a similar motivation to that of the Iceberg code. PCS uses pairs of parity checks to detect some but not necessarily all errors that occur in a given part of the circuit. The parity checks are chosen based on the symmetries already present in the circuit. For QAOA circuits considered in this work, the problem Hamiltonian X↔k Z↔k, so we use them as the checks of our PCS experiments. To unify the notation and checks is denoted as one syndrome measurement. For example, one syndrome measurement in PCS means that we select one cost Hamiltonian layer e↓iεH and sandwich it with two parity checks. The overhead of one syndrome measurement in PCS includes an additional 4k two-qubit gates, along with two ancillas. The comparison with PCS on a k = 18, ω = 11 QAOA circuit is shown in Fig. 1B and E, where all data are from the H2-1 emulator (H2-1E). We observe that PCS leads to a lower logical fidelity that does not increase with the number of syndrome measurements. At this scale, the large overhead and the non-fault tolerant design of the PCS method decreases the circuit performance. At the same time, we observe that the Iceberg code can effectively improve the QAOA performance and obtain a higher logical fidelity than the unencoded circuit with four syndrome measurements."
    },
    {
        "id_": "12162986-4c90-4118-8564-f91fd1719bf1",
        "text": "# B. Estimated performance from our model\n\nTo understand the protection capability of Iceberg code, we propose the performance model of Sec. V B for the unencoded and Iceberg code circuits. The model outputs analytical functions of the logical fidelity Fune for the unencoded circuits, the logical fidelity Fice for the Iceberg code circuits, and the post-selection rate 1 → D for the Iceberg code (D is the discard rate). Inputs from the circuit are the numbers of logical qubits k, logical single-qubit gates g1, logical two-qubit gates g2, and syndrome measurements s. From the hardware, the model for the unencoded and the Iceberg code respectively inputs only one and three error rates related to the noise produced by two-qubit physical gates. These are motivated and described in more detail in the next section. In this work we leave the error rates as fitting parameters so that, when fitted to data from the H2-1 emulator the fitted values incorporate corrections from other noise sources.\n\nSince QAOA experiments on hardware or emulators output the approximation ratio instead of the logical fidelity, we extend the performance model by approximating the noise distribution as that of a global white noise. Details are discussed in Sec. V C."
    },
    {
        "id_": "7f75a61a-1cd9-433b-8afc-2c6904a2ea98",
        "text": "# 1. Dataset and model validation\n\nWe use the emulator of the Quantinuum H2-1 quantum computer to generate a dataset with varying number of logical qubits in the range k ↘ [8, 26], QAOA layers in the range ω ↘ [1, 11], and syndrome measurements in the range s ↘ [1, 8]. This dataset contains 115 circuits for the Iceberg code and 56 for the unencoded circuits. We take 1000 shots for the unencoded circuits and 3000 shots for the Iceberg code circuits before post-selection.\n\nFrom this dataset we select partial data that have relatively stable logical fidelity and large numbers of two-qubit gates to fit the model. For the Iceberg code model,\n\n|Parameter|pcx|pc|pa|pω|\n|---|---|---|---|---|\n|Emulator|1.28e-3|[1.3e-05, 3.2e-05]|[4.3e-4, 1.1e-3]|[4.7e-4, 1.0e-3]|\n|Model|5.5e-3|7.0e-5|2.2e-3|4.4e-4|\n|CI|[5.0e-3, 6.2e-3]|[4.3e-5, 9.5e-4]|[1.9e-3, 2.5e-3]|[4.0e-4, 5.0e-4]|\n\nTABLE I. Error rates from the H2-1 emulator [8, 55, 56] and the performance model."
    },
    {
        "id_": "dfda6369-5e13-4324-9c05-ccdc09193678",
        "text": "# 5"
    },
    {
        "id_": "10daeb8d-1e9f-4ea9-92c3-1eec19c2b8b4",
        "text": "# CLogical fidelityAB\n\n|0.4|0.9|0.4|Model|0.95| |\n|---|---|---|---|---|---|\n| | |0.2|0.90|0.2|0.8|\n\n10 12 14 16 18 20 1 2 3 4 5 6 7 8 10 12 14 16 18 20 1 2 3 4 5 6 7 8\n\nk # syndrome measurements k # syndrome measurements\n\nFIG. 2. Proposed model accurately reflects behavior of Iceberg encoding circuits observed in high-accuracy emulation. The fitted model matches the qualitative and quantitative behavior of logical fidelity and post-selection rate for both varying qubit count with a fixed ω = 9 (A,C) and varying number of syndrome measurements with a fixed k = 16 and ω = 11 (B,D). The shaded regions represent the standard errors.\n\nthat has three fitting parameters, we use data from 64 encoded circuits while the data from 15 unencoded circuits is used to fit the unencoded model, that has only one fitting parameter. We additionally filter out those Hamiltonian terms of every QAOA circuit whose expected values are outliers with respect to the white noise approximation. More details are provided in Appendix B. The mean 3000 bootstrapping iterations are reported in Table I.\n\nTo validate the accuracy of the performance model, we present the logical fidelity and post-selection rate of experimental data alongside the model predictions in Fig. 2. We find that our model can match the experimental results both qualitatively and quantitatively.\n\nand experiment fidelities and post-selection rates for every selected circuit, as well as the deviations from the white noise simplification are presented in Appendix B. The values reported for the emulator in Table I are obtained from the parameters of the depolarising channel for the native two-qubit gates exp(→iϱZZ) and their dependence with the QAOA rotation angles ϱ ↘ {ϖ, ϑ}.\n\nThe depolarising channel assigns a probability q ϖ to each of the 15 Pauli errors in ς = P↔2 \\ {I ↔2 } after the native gate. The total probability of a Pauli error is the value of p cx reported in the table. These values are corrected by a multiplicative factor defined as linearly increasing function r(ϱ) ⇐ a + b|ϱ| in the angle magnitude, such that r(φ/4) = 1 for maximally entangling gates like the cnot. The error rate of unencoded logical gates is then p ϑ (ϱ) = p cx r(ϱ).\n\nFor the Iceberg code we additionally separate the error rate of commuting errors q c = q X →2 + q Y →2 + q Z →2 from that of anti-commuting errors q a = p cx → q c. To unify with the model error rates, we factorise this single channel into a product of a commuting channel with error rate p c (ϱ) = q c r(ϱ)(1 → q a r(ϱ)) and an anti-commuting channel with error rate p a (ϱ) = q a r(ϱ). We report the minimum and maximum among all QAOA rotation angles."
    },
    {
        "id_": "37fea274-2900-46aa-8103-c6db0769a361",
        "text": "# 3. Frontiers of the Iceberg Code performance.\n\nNext, we analyze the performance of the Iceberg QAOA circuits based on the fitted model. We report the difference Fice → Fune in logical fidelity between Iceberg and unencoded circuits in Fig. 3A, and the post-selection rate of Iceberg circuits 1→D in Fig. 3C, for varying numbers of syndrome measurements.\n\nAs observed from the shift of the breakeven frontiers in (red lines) in Fig. 3A, the QAOA logical fidelity stabilizes as the number of syndrome measurements increases, even though the post-selection rate, indicated by the orange."
    },
    {
        "id_": "e8810aef-ac31-416f-bf1b-23ec35f5e84d",
        "text": "# Difference of logical fidelity\n\n| | | | |kABk2x syndrome|Factor| | | |\n|---|---|---|---|---|---|---|---|---|\n| | | | |1|0.8|0.6|0.4|0.2|\n|6|106|0.0|106|0.0| | | | |\n|10| | |14|14|18|18| | |\n| | | |22|26|0.2|22|26|0.2|\n|30|34|38|42|0.4|42| | | |\n|46|46|0.0| | | | | | |"
    },
    {
        "id_": "18986623-fe0f-42ef-bc23-94d27e8e367c",
        "text": "# FIG. 3.\n\nModel prediction: Predicting the performance of QAOA with the number of logical qubits in the range k → [6, 48] and the number of QAOA layers in the range ω → [1, 16]. We use the model proposed in this work to estimate (A, B) the difference in logical fidelity between the Iceberg and the unencoded circuits, and to estimate (C, D) the post-selection rate. In A and C, we use the model fitted error rates in Table I and vary the number of syndrome measurements. In B and D, we fix the number of syndrome measurements at 4 and scale down the model error rates by the indicated factors. The red lines in the top row (A, B) show where the logical fidelity of Iceberg code circuits equals that of unencoded circuits. The orange lines in the bottom row (C, D) indicate where the Iceberg code circuits have a 10% post-selection rate.\n\nlines in Fig. 3C, decreases. This aligns with our experimental data and findings in the literature [18], which suggest that the initial syndrome measurements significantly enhance circuit performance, while the marginal gains diminish with an increasing number of syndrome measurements."
    },
    {
        "id_": "579b7d88-2e54-494e-aabc-326a47d8b56b",
        "text": "# 4. Predicting performance on future hardware\n\nWe now use our model to predict the performance of QAOA with the Iceberg code on future quantum hardware. To study this, we extrapolate the model performance by scaling all the model parameters in Table I by a varying factor. A smaller factor corresponds to smaller effective error rates, indicating higher fidelity of the quantum hardware. Scaling all error rates down by the same factor is clearly an additional simplification, as hardware development will not necessarily reduce all noise sources homogeneously and at the same pace. Nevertheless, this analysis provides a valuable qualitative perspective on the potential performance in a foreseeable scenario.\n\nAs shown in Fig. 3B and D, as the factor decreases, we observe a significant shift of the performance frontier to larger number k of logical qubits while the post-selection rate improves dramatically. This indicates that with higher-quality quantum hardware, we can push the breakeven frontier of logical fidelity to deeper circuits on larger problem instances with less post-selection overhead.\n\nTo elucidate the conditions for QAOA to become competitive with classical solvers, we use our model to answer the question of when a QAOA hardware experiment can outperform the Goemans-Williamson (GW) algorithm [57] in terms of approximation ratio. As reported in the literature [59], a noiseless QAOA with fixed parameters has been able to surpass the GW algorithm on small graphs. In Fig. 4A, we show an example of solving k = 16-node 3-regular graphs with noiseless QAOA, GW, and Iceberg QAOA with four syndrome measurements as well as unencoded QAOA emulated on the H2-1 emulator. The noiseless QAOA is able to outperform GW for ω ⇒ 6 layers. However, both the Iceberg and unencoded QAOA have not yet surpassed GW.\n\nSpecifically, at ω = 10, the approximation ratio of noiseless QAOA is 0.9810 . . ., while the average approximation ratio for GW is 0.9554 . . .. This implies that the logical fidelity of a noisy QAOA must be of at least 0.9554/0.9810 ⇐ 0.974 to outperform GW, assuming our white noise model approximation. In Fig. 4B, we vary the scaling factor of the model parameters to determine when this breakeven logical fidelity can be achieved. The results indicate that the Iceberg and unencoded circuits require scaling factors of approximately 0.81 and 0.60, respectively."
    },
    {
        "id_": "8222db46-9329-4eec-8df2-45d9ad731a60",
        "text": "# Logical fidelity"
    },
    {
        "id_": "0b0bc706-8d46-4802-9adb-262ca3da5ee0",
        "text": "# Post-selection rate\n\n| |A|B|\n|---|---|---|\n| |0.97|Iceberg QAOA|\n| |0.95|Unencoded QAOA|\n|0.90|0.95|Goemans-Williamson|\n|0.85|Noiseless QAOA|Iceberg QAOA|\n|0.80|Unencoded QAOA|0.94|\n| |Goemans-Williamson| |\n\n1.0 0.9 0.8 0.7 0.6 0.5 Scaling factor\n\nNoise decreasing\n\n2 4 6 8 10"
    },
    {
        "id_": "6b09ce22-b195-466b-8748-e1fc60e52cc4",
        "text": "# FIG. 4.\n\nHardware improvement necessary for QAOA to become competitive with the Goemans-Williamson algorithm. A Solve k = 16 MaxCut using different solvers. Each data is reported as the mean of approximation ratio over 100 k = 16 3-regular graphs. The standard errors are too small to be seen. B Scaling of model parameter to beat Goemans-Williamson (GW) algorithm for k = 16 graphs. The Iceberg code helps the QAOA to beat GW earlier than an unencoded one."
    },
    {
        "id_": "2c5f0de7-f6bb-4d0c-b094-f14a14d0ae73",
        "text": "# Comparison of Models\n\n||E|=27||E|=45|\n|---|---|\n|0.9|0.9|\n|0.8 Iceberg model|Iceberg H2-1E|\n|0.7 Unencoded model|Unencoded H2-1E|\n|0.6| |\n|0.3| |\n|0.2| |\n|0.1| |\n\n1 2 3 4 5 6 7 8 # syndrome measurements\n\n1 2 3 4 5 6 7 8 # syndrome measurements"
    },
    {
        "id_": "02949591-9131-4c7c-94ee-e2fa215d495e",
        "text": "# FIG. 5.\n\nComparison between experimental data and model predictions on random Erd˝os–R´enyi graphs with different numbers of edges. The prediction of Iceberg logical fidelity is less accurate compared to testing on 3-regular graphs, while the prediction of unencoded logical fidelity and the prediction of post-selection rate remain accurate."
    },
    {
        "id_": "e2ae177e-af37-4f44-a4b9-eb930f031aea",
        "text": "# IV. DISCUSSION\n\nWe demonstrate that the post-selected samples with the Iceberg code present a higher approximation ratio than the samples from unencoded circuits. This allows us to study the performance of QAOA in an effective noise regime closer to the noiseless computation; at least for circuits on the beneficial side of the breakeven frontier.\n\nWe can see the current breakeven frontier of the Iceberg QAOA on 3-regular graphs in Fig. 3A. For example, for 6 syndrome measurements, the breakeven frontier is up to k = 20 logical qubits for ω ↘ [4, 12] of QAOA layers.\n\n5. Model generalization beyond 3-regular graphs\n\nSo far, we have used 3-regular graphs to fit the performance model and analyzed the model’s performance on extrapolated 3-regular graphs. To test the generalizability of the model, we validate it on random Erd˝os–R´enyi graphs, which have different topologies compared to 3-regular graphs. We fix the number of nodes at k = 18, set the number of edges as |E| ↘ {27, 45} with all edges generated randomly, and select one graph for each of the two sizes.\n\nWe present the comparison between experimental results and model predictions in Fig. 5. The model predictions for the logical fidelity of the Iceberg code circuits are less accurate, especially with the densest graph of |E| = 45 edges. The model predictions for the unencoded logical fidelity and the Iceberg code post-selection rates are comparably more accurate. This indicates that the fitted model works well for problems with similar topologies, but highlights the limitation of the model’s generalization to different problems. We suspect that the worse model performance on these graphs is caused by the different amount of unaccounted noise accumulated in the comparably deeper circuits for these graphs."
    },
    {
        "id_": "0b2aee89-473e-4496-99e9-6bf2fdf3e874",
        "text": "# Sherrington-Kirkpatrick model\n\nThis is because the Iceberg code can execute two-qubit logical rotations with no overhead, whereas one-qubit logical rotations require a noisier two-qubit physical gate. Iceberg QAOA could be more advantageous for dense graph problems where the number of two-qubit Z ↔2 terms in the problem Hamiltonian is much larger than the number of single-qubit X terms in the mixing Hamiltonian.\n\nSecond, the compilation of Iceberg circuits could be further optimized. We speculate that the high deviations of the error rates observed between the emulator and fitted error rates in Table I could be explained by a larger amount of memory noise accumulated in the highly sequential syndrome measurement blocks and the QAOA mixing layer than in the optimized unencoded circuits. Currently, we are using pytket [61] to compile the logical gates alone, but a better strategy that jointly compiles the logical gates and the error detection blocks of the Iceberg code could potentially improve hardware performance while reducing execution time.\n\nWhile performance extrapolation indicates promising results with improved hardware fidelity, we observe that, with fixed model parameters, increasing the number of syndrome measurements marginally diminishes the performance gains in the extrapolation heatmaps. Additionally, the overhead of post-selecting samples grows rapidly. This observation is consistent with the experimental results on the H2-1 emulator, indicating that the protective power of the Iceberg error detection code is limited. This reinforces the need for quantum error correction to achieve error rates low enough to run large-scale circuits."
    },
    {
        "id_": "8d4de90c-922d-4997-8d5b-76c17204be54",
        "text": "# Performance model\n\nThis section introduces the detailed model to predict the performance of the unencoded and Iceberg code circuits. To build the model outputs efficiently, we consider the following noise channels:\n\n- Uniform two-qubit depolarizing channel with error rate p ϑ after every two-qubit logical gate of the unencoded circuit: insert a random Pauli error from the set P ↔2 \\ {I ↔2 } on the gate support.\n- Uniform two-qubit depolarizing channel with error rate p cx after every two-qubit cnot gate in the error detection blocks of the Iceberg code circuit: insert a random Pauli error from the set P ↔2 \\{I ↔2 } on the gate support.\n- A noise channel with error rate p c that introduces a random error that commutes with both stabilizers after every logical gate of the Iceberg code: insert a random Pauli error from the set {X ↔2 , Y ↔2 , Z ↔2 } on the gate support.\n- A noise channel with error rate p a that introduces a random error that anti-commutes with both stabilizers after every logical gate of the Iceberg code: insert a random Pauli error from the set P ↔2 \\ {I ↔2 , X ↔2 , Y ↔2 , Z ↔2 } on the gate support."
    },
    {
        "id_": "ca57fddb-bca3-4d1c-914e-62cdd50ae4a6",
        "text": "# Location of syndrome measurements\n\nAs depicted in Fig.1A, in this work we place syndrome measurements evenly spaced in the circuit so that every block of logical gates has roughly the same number of logical gates.\n\nIn Fig. 6, we provide evidence supporting this strategy. The k = 16, ω = 11 logical QAOA circuit is evenly partitioned into eight blocks of logical gates and we introduce a single syndrome measurement in the seven intermediate positions between them. By comparing the logical fidelity obtained from these seven circuits, we find that the circuit with the syndrome measurement inserted in the middle (labeled 4) presents the highest fidelity, at the cost of the smallest post-selection rate."
    },
    {
        "id_": "a86901c9-855c-4602-a893-708ad31ee789",
        "text": "# Model for the Iceberg code\n\nOverall, we have one error parameter p ϑ for unencoded circuits, and three error parameters, p cx, p c, and p a for Iceberg circuits. The probabilities of no error P 0, one error P 1, and two or more errors P 2 in a set of g gates with error rate p are respectively defined as:\n\nP 0 (p, g) = (1 → p) g (10)\n\nP 1 (p, g) = gp(1 → p) g↓1 (11)\n\nP 2 (p, g) = 1 → P 0 (p, g) → P 1 (p, g) (12)\n\nWe additionally make two simplifications to construct the model outputs efficiently. The first one states that:"
    },
    {
        "id_": "725912d1-571e-46b3-a56e-1fdc00cca69a",
        "text": "# Simplification 1\n\nEvery undetected error produces a logical error, unless the fault-tolerance of the Iceberg code prevents it.\n\nFor unencoded circuits, since no error is detectable, every error produces a logical error by virtue of this simplification, so we model the unencoded logical fidelity as the probability of absolutely no error:\n\nFune = P 0 (p ϑ , g 2) (13)\n\nFrom the fault-tolerant design every single error in the error detection blocks of the Iceberg code is either detectable or acts trivially, so none of these single errors contribute to the logical infidelity of the Iceberg code. However, two or more errors can produce undetectable errors, that, by virtue of this simplification, produce a logical error. The usually implicit justification of this simplification is that the number of errors that act trivially in the circuit is exponentially smaller in the circuit size than the number of undetectable errors that act non-trivially at the logical level."
    },
    {
        "id_": "080036a3-d18f-497b-b617-083f544bcafc",
        "text": "# Model for the Iceberg code\n\nThe model for the Iceberg code incorporates the effects of error detection and fault-tolerance. To construct the model efficiently we divide the circuit into blocks of initialization, logical gates, syndrome measurement and final measurement, respectively, as depicted in Fig. 1. At every block we consider the probabilities of errors causing:\n\n1. a harmless error H if they excite no ancilla and no stabilizer and act trivially on the state, like a Z error before the measurement of an ancilla,\n2. a logical error L that excites no ancilla and no stabilizer but acts non-trivially on the state, like a two-qubit X↔2 error after a logical gate,\n3. an exciting error E that excites a stabilizer but not an ancilla, propagating such error to the next block without an immediate discard, like a single-qubit X error on a code qubit inserted by the last CNOT that acts on that qubit in a syndrome measurement,\n4. or a discarding error D that excites an ancilla, causing an immediate discard, like a single-qubit X error before the measurement of an ancilla.\n\nIn the absence of noise the state remains in the +1 eigenspace of the stabilizers and ancillas. An error that excites some of them brings the state to their →1 eigenspace, and making the error detectable. We say that exciting and discarding errors are both detectable errors, while harmless and logical errors are undetectable. The sum of the four probabilities adds up to 1 at every block.\n\nThese probabilities are initialized from the initialization block, and iteratively updated for every block of logical gates, syndrome measurement, and the final measurement. For example, when adding a block of g logical gates that can suffer internal errors, the input probability of harmless errors H from previous blocks updates to the joint probability H ⇑ HP 0 (p c , g)P 0 (p a , g) of an input harmless error and no internal errors. At the end of this iterative process we obtain analytical functions for the probabilities of the entire circuit. From those we can compute the model outputs for the Iceberg code."
    },
    {
        "id_": "93a49191-eb18-432b-a877-c1f01fada7ee",
        "text": "# Simplification 2\n\nErrors are evenly distributed across all possible excitation events. That is, for every number μ = 1 and μ ⇒ 2 of errors in a block with m ⇒ 0 ancillas the probability of all excitation events is the same and equal to 1/2 m+2. The excitation events are the 2m+2 possible ways to excite (or not) the m ancilla(s) and the two stabilizers.\n\nFor example, in the syndrome measurement block there are 16 possible excitation events depending on which of the two stabilizers and the two ancillas are excited or not by errors. Therefore, we assume that 1/16 of the errors excite no ancilla and no stabilizer, 12/16 of them excite an ancilla, and 3/16 excite a stabilizer without exciting the ancillas. This simplification allows to incorporate the error detection and fault-tolerance properties of the Iceberg code in a very natural way. Appendix C shows the deviations between the model predictions and the exact fractions computed for small Iceberg code instances."
    },
    {
        "id_": "823d0d07-b227-43a1-b69a-910701515f22",
        "text": "# Initialization block\n\nThe top part of Table II presents the contribution of every possible error in this block.\n\n|# errors|0|1|↓ 1|↓ 1|↓ 2|\n|---|---|---|---|---|---|\n|excited ancilla|no|no|no|yes|no|\n|excite stabilizers|no|no|yes|any|no|\n|fraction of errors|1|1/8|4/8|3/8|1/8|\n|contribute to|H ↔ P 0 (p cx , n + 3) + 1E 1 (p cx , n + 3)H D|L ↔ 3/8 P 1 (p cx , n + 3)1/8P 2|Initialize the circuit|E ↔ 1/2 P 1 (p cx , n + 3) + 1/2 P 2 (p cx , n + 3)3/8 P 2|D ↔ (p cx , n + 3) + (p cx , n + 3)|"
    },
    {
        "id_": "48571bc0-86b8-45d4-973c-5d13e1d5395e",
        "text": "# 10\n\n|input error|H|H|H|H|H|L|L|L|L|E|E|E|E|E|\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n|# anti-commuting errors|0|0|1|↓ 2|↓ 2|0|1|↓ 2|↓ 2|0|1|1|↓ 2|↓ 2|\n|# commuting errors|0|↓ 1|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0|↓ 0| |\n|excited stabilizers|no|no|yes|no|yes|no|yes|no|yes|yes|no|yes|no|yes|\n|fraction of errors|1|1|1|1/4|3/4|1|1|1/4|3/4|1|3/9|6/9|3/12|9/12|\n|contribute to|H|L|E|L|E|L|E|L|E|E|L|E|L|E|\n\nH ↔ HP0 (pc, g)P0 (pa, g)"
    },
    {
        "id_": "3ef9e5c1-cc46-4698-a03d-bc5543b4b201",
        "text": "# Update rules\n\nL ↔ H(1 ↑ P0 (pc, g))P0 (pa, g) + LP0 (pa, g) + 3/4 (H + L + E)P2 (pa, g)1/3 EP1 (pa, g) + 1/4 (H + L + E)P2 (pa, g)\n\nE ↔ EP0 (pa, g) + (H + L + 2/3 E)P1 (pa, g) + D ↔ D"
    },
    {
        "id_": "8b118443-491d-4bcd-bf62-ce3baf3d585e",
        "text": "# TABLE III. Classification of errors in the block of logical gates\n\nEach number μ = 1 and μ ⇒ 2 of errors indicated in the first row (columns 2, 3, 4 and columns 3, 4, 5, respectively), the table distinguishes the possible excitations these errors can cause on the ancilla (second row) and stabilizers (third row). Using the simplification 2 we compute the fraction of errors that contribute to each of the possible events and present them in the fourth row. The fifth row shows how this classification incorporates the fault-tolerance of the initialization block. Every single error is either harmless or detectable, while two or more errors that pass undetected (last column) produce a logical error by virtue of simplification 1. Aggregating the contributions provides the initialization of the circuit probabilities presented in the last rows.\n\nBlock of logical gates. To add a block of logical gates we need to update the circuit probabilities from the combination of the input errors from the previous blocks with the internal errors of this block. Since no discard is possible at the block of logical gates, the discard probability D is preserved. The top part of Table III presents the classification of input, internal anti-commuting and internal commuting errors. The fraction of errors is calculated again using the simplification 2. For undetectable input errors, internal two or more anti-commuting errors cause 4 possible excitation events depending on which of the two stabilizers are excited or not. In contrast, input exciting errors and single anti-commuting errors, each create 3 possible stabilizer excitations: only SZ excited, only SX excited, or both excited. Together they create 9 possible excitation events. In 3 of them the excitations cancel out (11th column) while 6 preserve some excitation (12th column). Similarly, two or more anti-commuting errors create 4 possible excitation events, depending on which of the two stabilizers get excited or not, so here 12 events are possible when combined with an input exciting error. The bottom part of the table presents the resulting update rules of the circuit probabilities to add a block of logical gates.\n\nSyndrome measurement block. Similarly to the block of logical gates, the contributions from every combination of input and internal errors are summarized in Appendix C. The main difference is that the circuit is immediately discarded if at least one of the two ancillas is excited.\n\nFinal measurement block. To add the final measurement block note that the stabilizer SZ is computed in post-process while SX is measured by the ancilla. Note also that the second ancilla of the block is a flag qubit, that can be excited only by internal errors, but not by exciting input errors. Contributions are summarized in Appendix C.\n\nFinally, after adding all blocks one by one, we obtain the model output analytical expressions for the circuit probabilities H, L, D (and the trivial E = 0). The post-selection rate is 1 → D and the Iceberg code logical fidelity is\n\nFice = H/(1 → D). (14)\n\nWe check in Appendix C that the first and second order terms at low error rates satisfy the expected behaviour 1 → Fice = (g1 + g2)pc + O (pcx + pa2 + pcxpa + pc). (15)\n\nThis confirms numerically the partially fault-tolerant nature of the Iceberg code: the only single errors capable of causing a logical error are commuting errors in the logical gates, but no single error from the other two noise sources can cause a logical error."
    },
    {
        "id_": "02767fc1-e524-464b-86f6-f951daf59448",
        "text": "# C. Approximation ratio and logical fidelity\n\nTo relate the logical fidelity and the noisy approximation ratio we consider that the circuit noise takes the form of a global white noise channel [62]\n\nϖ = F |ϑ↑ ↔ϑ| + (1 → F)2 ↓k I ↔k. (16)\n\nWe can then estimate the noisy approximation ratio from the modeled logical fidelity F ↘ {Fune, Fice} as\n\nε(ϖ) = |E| → F ↔ϑ|H|ϑ↑ / 2fmax. (17)\n\nThis is the approximation ratio estimated from the performance model that we report in this work. Moreover, we sometimes use the white noise channel to estimate the logical fidelity from the samples obtained by running the unencoded circuits and the Iceberg code circuits on hardware or the emulator. In this scenario we have access to the experimental approximation ratio."
    },
    {
        "id_": "b5e1c102-2bf8-4095-8725-a86ee6b02a09",
        "text": "# Model fitting\n\nFor the unencoded circuits, we use the least squares method as a loss function to minimize the residual be-\n\ntween the model logical fidelity Fune and the experimen-\n\ntal ratios obtained from the unencoded circuits. For ev-\n\nery QAOA instance c, we compute the set of ratios Fc,une and then aggregate them all to the loss function:\n\nlune(Fune) = ∑c↑Cune l(Fc, Fune)\n\nWhen we have access to the experimental implementation of the QAOA circuits on hardware or on the emulator this is the estimated logical fidelity we report in this work.\n\nGiven a graph with edges Ec solved by the QAOA circuit c, we additionally consider the set of ratios\n\nFc = {Zj↑ | (i, j) ∈ Ec}\n\nobtained from the experimental expected values Zj↑c. Note that in general these experimental ratios are not ex-\n\npected to take the same value for all edges, but under the white noise channel, they all equal the channel fidelity.\n\nTo quantify the deviation between the experimental data and the white noise simplification, we consider the normalized distance between the experimental logical fi-\n\ndelity and the ratios as\n\nd(Fc, Fc) = |Ec|√l(Fc, Fc), with\n\nl(Fc, Fc) = ∑i,j (Fij → Fc)2."
    }
]