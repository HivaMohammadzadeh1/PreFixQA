[
    {
        "id_": "1cb95567-4182-4668-a1fd-9a048bfff7ec",
        "text": "# 1 Introduction\n\nContext. The number of potential use-cases for quantum computing steadily increases, whether in the noisy intermediate-scale quantum regime or using larger machines to perform fault-tolerant computations, with a diverse range of applications from pharmaceutics, material research, finance, to defence.\n\nHowever, most end-users will likely prefer not to own a quantum computer but still want to leverage its capabilities for their applications. The optimal strategy, therefore, Luka Music: Corresponding author, luka.music@quandela.com"
    },
    {
        "id_": "dc1d930a-cb3b-4e7a-8bac-08dbe7d3fcb9",
        "text": "# Classical and Quantum Channels\n\n|Classical Channel|Semi-classical Channel|Clients|\n|---|---|---|\n|Classical|Quantum|Classical Channels|"
    },
    {
        "id_": "df80c720-23cd-466e-a54f-7f757a647807",
        "text": "# Server\n\nFigure 1: Typical client-server configuration where a limited client delegates a quantum computation to a quantum server. Clients might have a limited quantum capability e.g. the ability to send single qubits [left] or entirely classical channels [right]. In this work we focus on a hybrid proposal where clients have a semi-classical channels [centre] meaning that the client is able to send a coherent state.\n\nis to use delegated solutions where quantum computations are performed by a quantum service provider. This approach is actively being developed in both academic and industry settings.1 This is commonly done via the combination of a code-based interface for describing the computation and classical communications between the client and the server.\n\nUnfortunately, in this scenario there are no information-theoretic guarantees ruling out a malicious provider accessing all information about the client’s desired computation, inputs, and outcomes. Cases where such considerations could be critical include (i) the manipulation of highly sensitive input data, such as confidential medical records or defence-related information, (ii) the execution of proprietary (and confidential) algorithms, and (iii) cases where the output is valuable, e.g. patent-worthy. Furthermore, the client cannot check in general that the service provider has performed its desired computation based only on the received output. The more powerful quantum computers are, the more problematic these issues become, as they grow capable of solving more and more advanced problems. All these considerations sti!en the adoption of quantum computers precisely at the time when they become useful for solving real-world problems. It is therefore vital to protect clients in these scenarii to foster wide-spread use of quantum computing technologies.\n\nThankfully, we can entirely remove the need for clients to trust their quantum service providers, with the help of quantum cryptography. Although quantum computers will be a threat to the security of some classical protocols (e.g. RSA)[1], they also open up"
    },
    {
        "id_": "9fcbbc6e-a7c3-45df-8630-c5be7b516b2e",
        "text": "# Footnotes\n\n1 Examples of public-accessible cloud platforms include: Quandela https://cloud.quandela.com, IBM https://quantum-computing.ibm.com, IonQ https://ionq.com/quantum-cloud, Rigetti https://docs.rigetti.com/qcs/."
    },
    {
        "id_": "dc25814d-f4ea-4d6a-8650-83a71d446705",
        "text": "# New Possibilities via Cryptographic Protocols\n\nsuch as quantum key distribution [2]. In our particular case, protocols for Secure Delegated Quantum Computing (SDQC) have been a highly active research field in the past few years and represent an extremely promising application [3–7]. These protocols allow a client with limited quantum resources to delegate a quantum computation to a server, without the server learning anything about the quantum algorithm, the input which is being processed or the outcome of the computation. During the protocol’s execution, the client can furthermore test that the server is behaving as expected."
    },
    {
        "id_": "b10fa13b-d6d4-469f-9006-f7382158819b",
        "text": "# Related Work\n\nWhether SDQC protocols see wide-spread use will depend directly on how technically accessible they are from the point of view of both the client and the server. In this respect, there are two extremes. On one end of the spectrum lie protocols which require one-way qubit communications between the client and the server and rather involved quantum setups for the client – either a source of qubits [5, 8] or a way to measure those received from the server [9, 10], along with single qubit operations. These protocols are information-theoretically secure, meaning that their security relies on no assumptions beyond the laws of physics, and they leak no information whatsoever about the computation, input or output. They are also composable, i.e. their security is not affected by the context of execution and they can be freely reused as black boxes in larger constructions (e.g. secure multi-party computations). However, for many interesting use cases it may not be feasible to expect clients to have access to either a qubit source or measurement devices in the near term and so it is important to reduce the technological requirements on the client’s side.\n\nAt the other end there are protocols [7, 11–13] which only require the client to interact classically with the server instead of sending quantum states. However, they incur a significant overhead on the server’s side, since it must be able to execute large cryptographically-secure functions to generate encrypted qubits of which only the client knows the secret key. Furthermore, these protocols only provide computational security, meaning that it relies on the quantum hardness of a computational problem. Finding an efficient algorithm for said problem would automatically break the protocol’s security. It has further been proven that they cannot be composably secure without setup assumptions [14].\n\nThe middle ground is represented by the protocol from [15], whose efficiency in terms of communication was improved in [16–18]. The client here only manipulates and transmits semi-classical states, e.g. laser light for photonic applications, which drastically reduces the client’s technological requirements. However, not only is it only blind and does not allow the client to verify the server’s operation, there are three main challenges which limit its application. First of all, the server needs an efficient polarisation-preserving2 photon-number Quantum Non-Demolition (QND) measurement, a very demanding operation in practice. Moreover, it must be able to extract from each pulse one single photon to use in the rest of the protocol. Finally, the server needs to implement deterministic two-qubit photonic gates, which are also extremely demanding. We also note that the security is information-theoretic but not proven in a composable security framework in the original paper."
    },
    {
        "id_": "1bb26e8e-bbe7-4906-b8bb-e3f7a4763d0d",
        "text": "# Overview of Results\n\nHere, we propose a best-of-both-worlds protocol for SDQC using semi-classical communications that drastically reduces the technological requirements of"
    },
    {
        "id_": "a1ed12ef-89ad-4d5d-87fb-9d4093be0d7e",
        "text": "# 1. Introduction\n\nBoth the client and the server. In particular, the client does not need to manipulate qubits, only a phase-randomised attenuated laser source and active waveplates, while the server does not need photon-number QND measurements, nor deterministic photon-photon gates that were required in Ref. [15]. Furthermore, we prove that the security of our protocol is information-theoretic and composable in the Abstract Cryptography framework of [19]."
    },
    {
        "id_": "8104b23c-a2e4-4069-8bee-bd84190181a6",
        "text": "# 2. Technological Requirements\n\nFigure 2 shows the various technological requirements of [5, 15] and our protocol.\n\n|Photonic|Detectors|CZ|\n|---|---|---|\n|Quantum channel|Single-qubit source|Classical channel|\n|Photonic|Detectors|CZ|\n|Polarisation-preserving|Photon-number QND Measurement+|Photon Extraction|\n|Laser|Waveplates|Classical channel|\n|Quantum|Detectors|Spin CZ|\n|Semi-classical channel|Laser|Waveplates|\n|Classical channel| | |\n\nFigure 2: Hardware setup for performing three delegated computation protocols. The operations in the blue dashed boxes are performed by the client while the server handles those in the pink dashed boxes. Red, yellow, and blue elements correspond to operations that have a high, moderate, and low technological requirements respectively. In all three cases the client classically sends measurement instructions to the server and recovers the outcome. Top: UBQC protocol from Ref. [5]. Middle: BDQC protocol from Ref. [15]. Bottom: our SDQC protocol."
    },
    {
        "id_": "a786bbff-e6d4-4a31-8b2d-9a09a334f8d2",
        "text": "# 3. Measurement-Based Quantum Computing\n\nOur protocol relies on Measurement-Based Quantum Computing (MBQC), a paradigm in which a large entangled state called graph state is first created and the computation is performed by adaptively measuring parts of the state in a predefined order, consuming the entanglement in order to carry out the computation. Such computations can be performed blindly by having the client prepare encrypted single qubits and send them to the server."
    },
    {
        "id_": "5a829ac9-d369-4179-9b1b-133c2c0cded0",
        "text": "# Universal Blind Quantum Computation (UBQC)\n\nwho then entangles them. The entanglement operation commutes with the encryption, thus yielding an encrypted graph state. The client instructs the server to measure qubits from the encrypted graph state in a way which both undoes the encryption and performs the computation of the client’s choice. This is the basis of the original Universal Blind Quantum Computation (UBQC) protocol of [5]. The first challenge is therefore to emulate these single-qubit transmissions using only attenuated laser pulses. The second challenge is to reduce the number of entangling gates that need to be performed after the qubits have been generated."
    },
    {
        "id_": "83bb1eca-9899-4669-9a5a-a5808d999821",
        "text": "# Protocol 1"
    },
    {
        "id_": "2fb5376a-c80f-4134-b6ce-d64b7cfdf2d3",
        "text": "# GHZ privacy amplification for rotated states from weak coherent pulses (informal)\n\n1. The server initialises its quantum emitter in the state |+→.\n2. The client sends n randomly-polarised weak coherent pulses, which the server uses to excite its quantum emitter. The energy level structure of the quantum emitter induces as output a polarisation-encoded GHZ state that is Z-rotated by an angle corresponding to the sum of all random angles chosen by the client.\n3.\nThe server emits one photon using a non-rotated coherent pulse and attempts to measure the first n photonic qubits (generated by the client’s pulses) in the |±→ basis.\n4. If the number of unsuccessful measurements (i.e. no photon was detected) is too high, the client aborts. Otherwise the server applies a correction to the last remaining photon and the quantum emitter which depends on the client’s choice of angles and the measurement results. These corrections are specified in Protocol 3.\n\nAs expressed above, the client will send a sequence of phase-randomised attenuated laser pulses, with the polarisation of each pulse being chosen at random. This polarisation angle corresponds to the secret key which will later be used to encrypt the computation. The server receives these pulses and uses them to excite a quantum emitter with a qubit degree of freedom, such as a spin1/2, that can emit spin-entangled photons. The quantum emitter will have two roles. It will first act as a “laser-to-qubit converter” by converting a coherent pulse into a single photonic qubit. This role is somewhat similar to the Remote Blind Qubit State Preparation that was proposed in Ref. [15], but we execute it without having to perform a qubit-preserving photon-number QND measurement. Moreover, it will act as a “photon entangler” as the emitted photonic qubit will be entangled with the spin. The server exploits this property to produce an entangled state of photonic qubits, removing the need of performing demanding photon-photon entangling gates to produce the encrypted graph state. More precisely, it is possible to produce photonic linear cluster states with a single quantum emitter, with each photon being entangled in polarisation to the next emitted photon in the chain and the last one being also entangled to the spin [20–25]. Crucially, the state of each photonic qubit thus created inherits the polarisation angle from the pulse that was used to generate it. These chains of encrypted photonic polarisation-encoded qubits can then be combined to form the graph state supporting the client’s desired computation. Only the links between chains need to be done after the qubits have been emitted, which drastically reduces the amount of entanglement operations. These can furthermore be done via interacting quantum emitters to remove entirely the need for photon-photon entangling gates, by performing the entanglement operations between quantum emitters in between photon emissions."
    },
    {
        "id_": "f357e6e3-4aa9-4965-b4a5-be0b42a2911e",
        "text": "However, as in [15], an attenuated laser pulse necessarily leaks more information about the client’s secret key compared to a single qubit. This is due to the fact that the state of the laser pulse can be described as a redundant encoding of the single qubit state containing the secret key. Taking a simplifying assumption, we can overestimate the information leakage by considering that any multi-photon component in the input laser completely leaks the polarisation information. We therefore need to suppress this information leakage in a way which meshes nicely together with the qubit generation technique described above. Fortunately, it is possible to easily switch between generating chains of qubits and GHZ states simply by selectively applying a Hadamard operation on the quantum spin. The full protocol then generates chains of encrypted GHZ states instead of chains of single qubits. Each qubit in the GHZ states is generated with a different random polarisation angle. The result is a chain of encrypted GHZ states whose encryption key is the sum of the polarisation angles. Each GHZ state can easily be collapsed into a single qubit while preserving the encryption key via measurements on all qubits but one in the GHZ state in the |±→ basis, thus recovering the chain of single qubits used for the rest of the blind protocol. Intuitively, the server can learn the final encryption key of a given qubit only if all the angles used to generate the corresponding GHZ state have leaked. Therefore the final leakage probability is suppressed exponentially in the number of qubits per GHZ state.\n\nThis protocol exploits low-intensity lasers |ω→ which generally have a non-negligible vacuum component, | ↑0|ω→ |2. In that case, even with an honest server and without other sources of photon loss, the quantum emitter sometimes cannot emit a photonic qubit. Our protocol accounts for this scenario by introducing a threshold on the number of detected photons during the aforementioned collapse of the GHZ states. If the losses reported by the server are too high, the client simply aborts.\n\nThe end result of the protocol in this simplified example is the state →12 (|00→ + eiω |11→) for a random angle ε known only to the client. The first qubit corresponds to the quantum emitter’s qubit degree of freedom, while the second is the state of the remaining polarisation-encoded photon. This gives a lot of flexibility in how the server can use this protocol to construct a larger graph state since the emitter and photon are still entangled. The server can easily extend this into a linear cluster state by repeating the protocol, or continue growing this rotated GHZ state so that it has multiple photons available for performing graph fusion operations.\n\nWe show that both the protocol’s security error and correctness error decrease exponentially with the number of pulses sent by the client (stated formally in Th. 5 and proven in App. C)."
    },
    {
        "id_": "9a9e6d64-f72f-4a44-b757-2354099b03c5",
        "text": "# Theorem 1 (Blind state preparation from weak coherent pulses, informal).\n\nThe probability of obtaining an incorrect state and the probability that information about the angle ε leaks to the server both exponentially decrease in the number of pulses n, as proven in a composable security framework."
    },
    {
        "id_": "3cb245f8-2208-4621-ad3a-fa7115446efb",
        "text": "# Theorem 2 (Blind Delegated Quantum Computation (BDQC) from weak coherent pulses, informal).\n\nThere exists an efficient composably secure BDQC protocol with an exponentially-low security error in which the client only sends weak coherent pulses and the server only manipulates interacting quantum emitters.\n\nWe then use this to build a protocol for SDQC. In addition to BDQC’s blindness, SDQC also guarantees that the server performs the client’s computation as instructed.\n\n6"
    },
    {
        "id_": "3253d3c0-d1c0-4f62-877e-89ba876f1eb0",
        "text": "# Theorem 3\n\n(Secure Delegated Quantum Computation from weak coherent pulses, informal). There exists an efficient composably secure SDQC protocol for delegating BQP computations with an exponentially-low security error in which the client only sends weak coherent pulses and the server only manipulates interacting quantum emitters.\n\nFinally, we study the experimental feasibility of our protocol by computing the trade-off between correctness and security in the presence of loss. Recent experimental developments in that regard show extremely promising results [22–25, 27] and hold the current record for the largest entangled photonic state produced [25]. Our scheme is thus not only secure but also experiment-ready."
    },
    {
        "id_": "29e520f5-0de0-416b-b9bd-21abaa203f66",
        "text": "# Comparison with Dunjko et al. [15]\n\nThe protocol from [15] works by having the server non-destructively measure the client’s coherent light pulses in photon number, and post-select only the light pulses containing at least one photon. Then, the server must isolate one photon from each pulse. It applies a privacy amplification step which requires as many CZ gates as there are photons. After that, the server also has to entangle the privacy-enhanced photons into the graph state supporting the client’s computation by using photon-photon CZ gates. All four of these steps are challenging technological requirements.\n\nThe Remote State Preparation (RSP) in Ref. [15] – performing a polarisation-preserving QND measurement to count the photons in each pulse and extracting a single qubit from pulses containing at least one photon – is separated from the privacy amplification and the graph state generation. This first step has been implemented by [18], requiring a number of pulses from the client which is around 108 per qubit in the graph in the best case scenario where there is virtually no spatial separation between the client and server. They solve the issue of performing a QND measurement and qubit extraction – which previously required a much more complex process [28, 29] – by using a linear optical setup performing teleportation with EPR pairs. Although this is rather fast – their experiment generates 1011 leaky qubits via this RSP technique in two hours – they still need to entangle these polarisation-encoded base qubits using photonic gates to perform the privacy amplification, which is not done in [18]. Since they claim to want to use these 1011 leaky qubits to generate 103 leak-free qubits, this implies a multiplicative overhead of 108 in terms of entangling photonic gates compared to the client’s base computation. The only viable option in this setting is to use deterministic non-post-selected photon-photon entangling gates since anything else will degrade far too rapidly to be useful. Unfortunately, the fidelities of such gates which have been demonstrated [30–32] are still insufficient to apply such a number of operations while preserving the integrity of the quantum state, even with error-correction techniques.\n\nOn the other hand, our RSP technique using a quantum emitter is intrinsically intertwined with the privacy amplification and graph state generation steps: the entanglement required for these two processes is directly generated by the structure of the quantum emitter and no additional operations are required. The result is that the final qubits are"
    },
    {
        "id_": "9a06e321-ba9e-42e8-b7d7-8d16c4bf4168",
        "text": "# Current Page\n\nPositioned in the graph at the same time as they are produced with a polarisation that is unknown to the server. Our full protocol does not require any non-destructive photon measurements nor deterministic photon-photon gates. Instead, it requires quantum emitters with a spin degree of freedom, with a level structure that enables the emission of spin-entangled photons that are also efficient light sources. Single atoms and artificial atoms such as quantum dots or defect color centres inserted in optical microcavities or waveguides are natural choices for such spin-photon interfaces.\n\nOur scheme can naturally generate linear cluster states from a single quantum emitter. In order to perform universal computations, multiple states of this kind must be entangled together. This can be done in one of two ways.\n\nIf multiple spins generate linear cluster states in parallel and these spins can interact with each other, then applying nearest-neighbour spin-spin CZ gates when the clusters should be linked is sufficient to obtain universality [33]. This is rather demanding since it requires either independently controlling chains of single atoms or artificial atoms such as quantum dot molecules, or the availability of a spin register such as a 13C nuclear spin for color centres in diamond.\n\nOtherwise, it is possible to implement these operations with linear optics, via fusion operations and delays. The server can leverage the flexibility in our RSP technique to generate additional photons in each GHZ state and use these photons to implement fusion gates between different linear clusters as in [34], at the cost of an increased sensitivity to photon loss of the probability of generating the target blind graph."
    },
    {
        "id_": "fd697804-34fa-4614-bd59-a54dd6032667",
        "text": "# Comparison with Takeuchi et al. [35]\n\nA recent paper [35] also proposed a protocol for information-theoretically secure SDQC using only semi-classical light. There are however significant differences both in terms of results and techniques. Their protocol is based on the SDQC protocol from [36] and requires the client to send states sampled from the same set as in our construction. The privacy amplification technique is similar to ours and that of Dunjko et al. However, their construction requires the same complex operations as Dunjko et al as well: QND measurements and photon-photon entangling gates. As such they do not resolve the issues stemming from these operations and our protocol is therefore much more suitable for implementation. Furthermore their security is not proven in a composable framework such as the one used in the present paper, meaning that their security guarantees do not automatically hold if an outcome of their protocol is later reused in another cryptographic construction."
    },
    {
        "id_": "2f8df8c4-e6b7-44be-b59a-1875c11b1a11",
        "text": "# Organisation of the paper\n\nWe start by giving preliminaries on (i) the generation of photonic graph states, and (ii) delegated quantum computing protocols. In Section 3, we present our protocol for securely preparing encrypted graph states from semi-classical light and its application in blind and secure delegated protocols. Later in Section 4 we analyse the success probability of our protocol on realistic hardware, taking into account multiple effects leading to photon loss. Finally, we discuss the merits of and possible improvements to our protocol in Section 5."
    },
    {
        "id_": "8983f6cc-c16a-4fb6-8762-3973872667d6",
        "text": "# 2 Preliminaries\n\nSection 2.1 presents how to generate graph state from quantum emitters and weak coherent pulses. Then Section 2.2 describes the UBQC protocol that allows a client to blindly delegate quantum computations to a server. Additional preliminaries can be found in Appendix A, in particular Appendix A.2 presents the composable Abstract Cryptography."
    },
    {
        "id_": "6285dd5b-f28c-4d16-b7c6-7e959b9f1882",
        "text": "# 2.1 Graph state generation using quantum emitters\n\nWe describe here how to generate a cluster state from coherent pulses and quantum emitters using the technique from [37]. A graph state is a quantum state defined by a graph G = (V, E) such that all vertices v ↔ V are associated to qubits initialised in the |+→ state and an edge e = (v, w) ↔ E between two vertices corresponds to a CZ operation between the two qubits associated to vertices v and w. Formally the graph state is thus given by:\n\n|G→ = ∏(v,w)↑E CZv,w ⊗ |+→v.\n\nA cluster state is a graph state whose graph is a regular lattice. In Figure 3, we for example display a 2D-cluster state."
    },
    {
        "id_": "22d42f55-1605-406c-9e0a-d0592e5ca8ff",
        "text": "# Figure 3:\n\nA cluster state of n = 3 rows and m = 4 columns. Each circle represents a qubit in the |+→ state and each edge corresponds to the application of a CZ operator between adjacent qubits.\n\nBob can generate these states by using coherent pulses to repeatedly excite quantum emitters with a spin degree of freedom3 and spin-selective transitions which can emit spin-entangled photonic qubits.\n\nMore precisely, we denote |↗→ and |↘→ the computational basis states of the spin qubit. After excitation, we assume that the quantum emitter will spontaneously emit a photonEqe whose polarisation is correlated to the spin state as follows: |↘→ ↓↓≃ |↘, R→ and |↗→ ↓↓≃ |↗, L→. Overall, an excitation with a weak coherent pulse followed by radiative decay yields the following emission operator for our quantum emitter:\n\nEqe = |↗, L→ ↑↗| + |↘, R→ ↑↘|,\n\nwhere |L→ , |R→ denote respectively left and right polarised photon states.4 A simple example of such transitions is displayed in Fig. 4 and corresponds to a singly-charged single quantum dot.\n\n3 Any other qubit degree of freedom would work.\n\n4 We associate states |→↑ , |L↑ to |0↑, and |↓↑ , |R↑ to |1↑."
    },
    {
        "id_": "c91fed43-31c7-4954-ac61-28bad1fccc47",
        "text": "# (a) Lambda-type excitation scheme"
    },
    {
        "id_": "6daaa3e0-e3ec-48e9-8ee4-b7f789d974e6",
        "text": "# (b) Spin-photon entanglement generation\n\nRi\n\nLi\nL\nL\n\nFigure 4: Energy level structure of a quantum emitter suitable for our BDQC protocol with semi-classical light communications, such as a negatively-charged quantum dot.\n\nThe operation Eqe can equivalently be expressed as applying a CNOT between the quantum emitter and a photon in the |0→ph state as in the following circuit:\n\n||ϑ→qe|•||ϑ→qe|\n|---|---|---|\n||0→ph| | |\n\nStarting from a spin in state |+→qe := 1/√2 (|↗→ + |↘→), applying the emission operator generates a Bell state including one photon and the spin qubit:\n\n|!→ = 1/√2 (|↗→ |L→1 + |↘→ |R→).\n\nThis Bell state can be seen as a redundantly encoded |+→qe state. Applying a Hadamard gate on the spin then generates a two-qubit linear cluster state where one vertex contains the spin qubit and the other is comprised of the polarization qubit:\n\nCZqe,ph\n\n+→qe\n\n+→ph\n\nThis process can be represented as in the following Figure 5:\n\nFigure 5: Basic linear cluster generation process. Starting from an appropriate quantum emitter in the |+→qe state (small square), a Bell state |!→ is created via emission of a photon (small circle) and then transformed into a cluster state. The middle circle containing two elements represents the Bell state as a redundantly-encoded |+→ state.\n\nIntuitively, we can see that applying multiple times the emission operator grows the number of qubits inside the vertex containing the quantum emitter, while applying a Hadamard gate moves the quantum emitter to an adjacent vertex. The process can then be repeated to construct a linear cluster with redundantly-encoded vertices.\n\nTo generate a cluster state with n rows and m columns, we use n quantum emitters placed in a line which can each quantumly interact with its neighbors via a CZ operation. We first apply a CZ between each quantum emitter and its neighbors, then make each quantum emitter emit one photon and apply a Hadamard on the spin of the emitter. This process is repeated m times, after which the quantum emitters are measured in the Z basis."
    },
    {
        "id_": "eaa030e8-b3cb-4c5d-acdd-e43d5f5d1a2f",
        "text": "# Figure 6: Generation of a cluster state of n = 3 rows and m = 4 columns."
    },
    {
        "id_": "4bd53ed4-a3aa-4e20-8b37-a24545b07d5e",
        "text": "# (a) First step in the cluster state emission.\n\nStarting from n = 3 quantum emitters, we apply a CZ gate between each pair of neighbours, followed by an emission operator and Hadamard on all emitters."
    },
    {
        "id_": "9f599042-092e-425b-bfed-be2f5539d8f5",
        "text": "# (b) Result after repeating the process in Figure 6a m = 4 times.\n\nThe quantum emitters are then measured in the Z basis. This yields the state from Figure 3 encoded in the polarisation of the emitted photons."
    },
    {
        "id_": "0cf4cd7a-5b5d-4ab9-a441-6ab350bb5fbf",
        "text": "# 2.2 Delegated quantum computing protocols"
    },
    {
        "id_": "940561b7-0827-4b4a-a035-6a95e4af0572",
        "text": "# 2.2.1 Measurement-based quantum computing\n\nWe start by describing how computations are performed in the MBQC model for classical inputs and outputs. Alice’s computation is defined by a so-called measurement pattern which consists of a graph G = (V, E, I, O), with vertex and edge sets V, E, input vertex set I and output vertex set O, a partial order ⇒ over V, a set of angles {ϖv}v↑V and a flow function f from non-output vertices V \\ O to non-input vertices V \\ I.\n\nThe computation starts by producing on Bob’s machine the graph state |G→ associated to the graph G: for each vertex in V one qubit is prepared by Alice in the state |+→ and sent to Bob, who then applies a CZ v,w operation between each pair of qubits associated to vertices v, w joined by an edge in E.\n\nThe Z basis measurement can be done by emitting an auxiliary photon using E qe and measuring it in the Z basis."
    },
    {
        "id_": "c6be9b85-1ca6-4ca2-a3e2-9673d2c67225",
        "text": "# Quantum Computation and Delegation\n\nAlice can then perform a quantum computation on the graph state generated by Bob by instructing him to measure vertices in the order ⇒. These measurements are performed in the X ↓ Y plane of the Bloch sphere, i.e. measurements in the |±ε → = 1→2 (|0→ ± eiε |1→)/ bases. The measurements are specified for each vertex v by the angle ϖv.\n\nIf a measurement outcome on a non-output vertex is 1, some future measurement angles must be adapted in order to perform the same computation as if the measurement outcome had been 0. The flow function f prescribes how the base angles {ϖv}v↑V change due to this effect, see [47] for more details. We will note ϖ↔v the updated angle.\n\nIn the case of classical outputs, the outcome of the computation is given by the measurement results on vertices from set O after corrections given by the flow are applied.\n\nThis scheme is universal when using specific graphs, either brickwork graph states [5] or cluster states [48], and measurement angles ϖv chosen from the set ” = {jϱ/4 | j = 0, 1, . . . , 7}.\n\nFollowing this procedure allows Alice to delegate any quantum computation of her choice, at the cost of revealing it entirely to Bob."
    },
    {
        "id_": "eeab2651-6c51-4d76-9a17-55a9dd118330",
        "text": "# 2.2.2 Blind delegated protocol\n\nThe goal of the UBQC protocol is to allow Alice to perform the same task but without Bob learning anything about her desired computation. In the original UBQC protocol [5], Alice also sends qubits to Bob, but their initial state is chosen among |+ω → = 1→2 (|0→ + eiω |1→)/ with ε ↔ ”. We can rewrite this state as |+ω → = RZ (ε) |+→, with:\n\n(iεZ)= cos(ε/2)I ↓ i sin(ε/2)Z\n\nRZ (ε) = exp ↓ 2\n\nSince RZ (ε) commutes with CZ applied by Bob after receiving Alice’s qubits, the resulting state is a graph state up to local rotations RZ (ε) on each qubit:\n\n∣∣∣ G(ε)〉=ς  ∏ CZ v,w RZ (ς) ⇑v↑V  ε |+→v = RZ (ς) |G→ , ε\n\nwith\n\nRZ (ς) = ∏ v(ε v )\n\nwhere ες is a vector corresponding to all the angles ε v applied on each vertex v ↔ V, and the v index in RZ denotes on which qubit the rotation is applied. We will call any graph ς a blind graph state.\n\nTo perform the same computation as before, instead of measuring the qubit at vertex v ↔v using the measurement angle ϖv ↔, Alice will instead request that Bob use the angle φ v = ϖ +ε v +r v ϱ. Consequently, since the measurement with angle φ v is performed by applying RZ (↓φ v ) and measuring in the |±→ basis, the ε v from the measurement angle will cancel out the ε v applied during the state generation and apply Alice’s desired computation. It will at the same time perfectly hide the value of ϖ↔v in φ v. The value of r v is chosen uniformly at random from {0, 1} to randomise the outcome of the measurement. This is required.\n\nMBQC is exactly universal if we allow arbitrary angles from [0, 2ω), and it is approximately universal for 2k angles of the form 2jω/2k so long as k ↔ 3, see [49]."
    },
    {
        "id_": "937eefa4-3f82-44f9-bc78-75b0eecd6d7f",
        "text": "# 2.2.3 Secure delegated protocol\n\nSecure Delegated Quantum Computations (SDQC) protocols not only ensure that Alice’s information remains private, but also provide verifiability. This property guarantees that Alice either receives the correct output or aborts the computation due to Bob deviating from his prescribed operations.\n\nVarious techniques have been developed for inserting tests alongside Alice’s computation of interest to check that Bob’s behaviour is honest [8, 50, 51], but most require the preparation of both rotated |+ω → states and states in the computational basis. These are used to isolate qubits in the graph so that Bob’s measurement of these qubits returns a deterministic result if performed correctly. Such isolated qubits can then be used to test Bob throughout the execution of the computation.\n\nWe present here the protocol from [26] for classical input/output BQP computations which uses only |+ω → states. Alice and Bob repeat the same UBQC execution N times, using a random fraction of the executions to test Bob’s honesty via deterministic computations whose outcomes are known to Alice. If less than a given fraction of these tests pass, Alice aborts. Otherwise she computes the majority outcome of the UBQC runs which performed her desired computation.\n\noperations of the form Sv = Xv∏(v,w)↑E Z w – called the graph’s stabilisers. A test is then defined by a product of these stabilisers Sϑt = ∏v↑V Stv v for a bit string ς ↔ {0, 1} |V | . To perform the test associated to stabiliser S, Alice instructs Bob to measure all vertices in the Pauli bases given by this stabiliser. She then computes the parity of measurement outcomes and the test passes if it is 0.\n\nIn UBQC, Bob only performs measurements in the X ↓ Y plane, therefore Ref. [26] requires that Alice only uses tests Sϑt such that Sϑ t does not act as Pauli Z on any vertex v. Then the state preparation and measurements for tests and computations are indistinguishable since both can be hidden via a UBQC overlay. For various types of graphs including the brickwork and cluster graphs, Ref. [26] then defines sets of such tests from which Alice draws at random when she must perform a test run during the protocol’s execution.\n\nRef. [26] show that these tests can catch all of Bob’s deviations which may corrupt Alice’s computation in the case of classical outputs. Then, if N is the total number of UBQC executions, the probability that Alice accepts an incorrect outcome at the end of the SDQC protocol decreases exponentially with N.\n\nFor completeness sake, we describe in Appendix A.1, Protocol 5 the full SDQC protocol for classical inputs and outputs, and provide the formal security statement in Appendix A.2, Theorem 10."
    },
    {
        "id_": "c852f753-8891-4a9a-b077-8ca1e22c44fe",
        "text": "# 3 Remote state preparation with semi-classical clients\n\nThe security of the delegated quantum computation protocols presented in the previous section rests on the fact that Bob cannot access information about the secret angle ε v with"
    },
    {
        "id_": "c45c5351-e78a-41a5-9466-bdc388c8de12",
        "text": "# 3.1 Blind graph state generation using quantum emitters\n\nInstead of sending single qubits, in our protocol Alice transmits coherent states to hide the phases ς. The main advantage is that a photonic attenuated coherent state source is simply a laser light which is already commercially available and likely to remain much more economical than a source of single qubits. Such a coherent state |ω→ω with ω = |ω|eiϖ is given by:\n\n|ω→ω = e↗|ϱ|2/2 (8)\n\nwhere aω † := cos(ε)aR + sin(ε)aL is the rotated polarisation creation operator and |↼→ is the vacuum state. Using a phase-randomised laser, Alice instead sends the state:\n\n2ςϖ=0∣∣∣|ω|eiϖ 〉|ω|eiϖ ∣∣∣ ω d⇀ = e↗|ϱ|2 (9)\n\nOn the other hand, Bob must convert these coherent states into single qubits while preserving the polarisation in order to use them in the UBQC protocol. This can be done using the scheme presented in Section 2.1 with a slight modification of the emission operator in Eq. (2). If Alice’s light source sends the state ↽ϱ,ω such that it is able to drive the optical transition of the quantum emitter from Figure 4, the production of spin-entangled photon states is done via the following global operation:\n\nEqe(ε) = |↗, L→ ↑↗| + eiω |↘, R→ ↑↘| = RZ (ε)Eqe. (10)\n\nThe polarisation of the input coherent laser therefore imprints a phase on the photon after emission, corresponding to a RZ (ε) rotation described in Section 2.1, then the resulting state is the rotated cluster state ∣∣∣ G(ε)〉, which is the required resource for both the UBQC and SDQC protocols as shown in Eq. (6). Intuitively, so long as all the angles εv are hidden from Bob, the UBQC protocol which uses this strategy for generating the blind graph remains secure. We now introduce a new resource in the Abstract Cryptography security framework and then describe a protocol which formalises this idea. For unitary U, we write U(↽) to mean U↽U†. Furthermore, when applying CNOT operations, we always assume that the first qubit mentioned is the control while the second one is the target."
    },
    {
        "id_": "b1155fe7-9869-47e4-87b0-546c90228045",
        "text": "# Resource 1 Blind Graph State Extender\n\n|Inputs:|Computation by the resource:|\n|---|---|\n|Alice inputs an angle ε ↔ ”.|The resource samples a bit b ↔ {0, 1} uniformly at random and sends to Bob the two-qubit state RZ ((↓1)b ε)CNOT (↽B ⇑ |0→↑0|), where RZ is applied to the second qubit.|\n\nThis resource captures the perfect setting where the rotated emission operator Eqe(ε) is applied to Bob’s quantum emitter without leaking any information about the state."
    },
    {
        "id_": "8c177800-f5bc-4044-8399-238418a3989d",
        "text": "# Blind Graph State Preparation from Blind Extensions\n\nPublic information: Graph G = (V, E) and an ordering &lt; over vertices decided by Bob.\n\nInputs: Alice inputs a set of angles ες ↔ ” |V |."
    },
    {
        "id_": "d70bce21-5569-49cd-b323-5f3fd74e8b5d",
        "text": "# Protocol:\n\n1. Bob initialises the spin qubit of all his quantum emitters in the state |+→qe.\n2. For each vertex v in the graph, in the order &lt;:\n1. Alice and Bob perform a call to the Blind Graph State Extender Resource 1:\n- Alice inputs the angle εv. Bob inputs the spin qubit of quantum emitter q such that v ↔ Vq.\n- Bob receives as output two qubits along with a bit bv.\n2. Bob applies Xbv to both qubits it received and Zbv to any one qubit at the vertex v ↔ Vq preceding v, if it exists.\n3. Bob produces a number nv of his choice of additional qubits using the emission operator Eqe.\n4. Bob performs all entanglement operations between vertex v and the vertices w &lt; v such that (v, w) ↔ E. These can be performed either via:\n- CZ gates between quantum emitters q and r where v ↔ Vq and w ↔ Vr, if r is still situated at vertex w;\n- fusion operations between the additional qubits generated by Bob at vertices v and w.\n5. Bob applies a Hadamard gate to the spin qubit of quantum emitter q.\n3. Bob decorrelates his quantum emitters from the polarisation-encoded graph state by performing:\n1. a measurement of each spin qubit q in the computational basis with outcome cq;\n2. a correction Zcq on a qubit of vertex vq where vq is the last element of Vq.\n4. If there are leftover additional qubits at any vertex v, Bob measures them in the |±→ basis. Let dv be the sum of measurement outcomes, Bob applies Zdv to the remaining qubit at vertex v."
    },
    {
        "id_": "d69eb9f4-cf9e-4938-a79b-188e8fa804a2",
        "text": "# Protocol Security\n\nThe blind graph state generation protocol (Protocol 2) perfectly constructs the Blind Graph RSP Resource 2, meaning that the security error is exactly 0. This is captured by Theorem 4, whose proof can be found in Appendix B."
    },
    {
        "id_": "684777a7-f8bd-4eea-9757-3bf99b7c08bd",
        "text": "# Theorem 4 (AC security of Protocol 2)\n\nProtocol 2 perfectly constructs in the Abstract Cryptography framework the Blind Graph RSP Resource 2 from |V| instances of the Blind Graph State Extender Resource 1."
    },
    {
        "id_": "b06e9cfb-c28f-4230-a2c3-71b3ce8b2cca",
        "text": "# 3.2 Security amplification via rotation aggregation\n\nIt would seem like simply exciting a quantum emitter via a pulse in the state ↽ϱ,ω would be enough to construct the Blind Graph State Extender Resource 1 since it is equivalent to applying the emission operator Eqe(ε). However this is not the case since a laser pulse leaks a non-negligible amount of information.\n\nDue to the phase randomisation step, Bob has access to a probabilistic mixture of states |k→↑k|ω. These states consist of k photons which each contain the same information about ε. If he performs a polarisation-preserving photon number resolving QND measurement, he can learn the number k of incoming photons for each vertex of the blind graph state. Bob can then choose to attack the vertex where he received the most photons.\n\nIf we assume that Bob is capable of manipulating each of these photons in isolation, the amount of knowledge that he can extract from the execution of the protocol directly |ω|2 increases with the intensity of the coherent state via the probability of obtaining multiple photons. On the other hand, a relatively high value for |ω|2 is desirable in order to excite the quantum emitter generating the blind graph state.\n\nIn order to recover the ideal scenario described by the Blind Graph Extender Resource 1, we make use of a security amplification gadget which exponentially suppresses the information leakage using only a linear number of pulses.\n\nThis protocol makes use of the GHZ-generation capability of the quantum emitter paired with the rotated emission operator Eqe(ε). Alice sends to Bob a certain number of phase-randomised rotated weak coherent pulses ↽ϱ,ωi for a fixed intensity |ω|2 and randomly chosen values of ε. Bob uses these pulses to drive the transition of his quantum emitter, effectively applying the rotated emission operator Eqe(εi). These consecutive pulses will generate a rotated GHZ state whose angle is the sum of all angles used by Alice for laser pulses containing at least one photon. Bob emits one last photon using Eqe and then measures all qubits generated by Alice’s pulses in the X basis. He can thus detect which laser pulses contained no photons. If too few photons have been detected, Alice aborts the protocol. This threshold, set by the security proof, prevents Bob from discarding too many pulses from which he would not get enough information. If Alice has not aborted, she communicates to Bob a correction which depends on her desired angle and the parity of the measurement outcomes. After applying this correction, Bob’s device contains the random rotated state chosen by Alice. This process is presented in Figure 8.\n\n||$%#⟩||$%\"⟩||$%!⟩|Θ!|∑Θ$|\n|---|---|---|---|---|\n|\"(θ)|\"(θ)|\"(θ)|\"(θ)|\"(θ)|\n|!!|Θ\"|Θ#| | |\n\nFigure 8: Example of privacy amplification with three weak coherent pulses in the lossless case. The laser with polarisation control on the left is in the hands of Alice while the quantum emitter (square) is handled by Bob. Alice sends three pulses with randomly rotated polarisations. Bob uses these pulses to drive the quantum emitter and then emits one more photon. The result is a five-qubit rotated GHZ state after the first arrow. Bob then measures (in orange) all polarisation qubits in the GHZ state but one in the |±→ basis. After correction, the result is a rotated Bell state containing the spin qubit and one polarisation qubit. This is the same state – up to rotation – as in the middle step of the basic linear cluster generation process from Figure 5.\n\nWe describe formally this process in Protocol 3.\n\n17"
    },
    {
        "id_": "7e133d41-f7ab-4a31-b354-a7ebbcd73254",
        "text": "# Protocol 3 GHZ privacy amplification for rotated states from weak coherent pulses"
    },
    {
        "id_": "28d0b20c-00cf-4be9-bac3-3ddd0e14e19e",
        "text": "# Public information:\n\nLaser pulse intensity |ω|2, number n of pulses sent per GHZ gadget, threshold t."
    },
    {
        "id_": "387c31cc-82cd-46f3-b413-965bc2cdf150",
        "text": "# Inputs:\n\nAlice inputs an angle ε ↔ ”. Bob inputs a single-qubit spin state ↽qe."
    },
    {
        "id_": "a36a999d-6c58-4da2-9dcd-058dd754b3d9",
        "text": "# Protocol:\n\n1. Alice samples values (ε1, . . . , εn) uniformly at random from ”.\n2. For 1 ⇔ i ⇔ n:\n1. Alice sends the phase-randomised rotated weak coherent pulse ↽ϱ,ωi to Bob.\n2. Bob uses this pulse to apply the rotated emission operator to his spin qubit Eqe(εi).\n3. Finalisation:\n1. Bob emits another photon using the emission operator Eqe. This qubit is indexed 0.\n2. Bob attempts to measure all photonic qubits i ↖ = 0 in the GHZ state in the |±→ basis. Let S ↙ {1, . . . , n} be the set of indices for which the measurement succeeded (i.e. a photon has been detected) and let b = i↑S bi be the parity of the corresponding measurement outcomes. Bob sends S to Alice.\n3. Alice aborts if |S| ⇔ t, sending Abort to Bob and setting it as her output. Otherwise, she samples uniformly at random a bit mx and the correction angle ¯ = (↓1)mx ε ↓ i↑S εi and bit mx to Bob.\n4. Bob applies the correction RZ(¯ + bϱ) to photonic qubit 0 and sets it as his output together with bit mx."
    },
    {
        "id_": "ca1948f6-d753-43f8-a75c-7537032b1cb1",
        "text": "# On the final correction operation.\n\nThe final correction might seem like a superfluous step, but it is necessary for proving the security of the protocol. In particular, the simulator built as part of the security proof requires this flexibility to adapt its behaviour to the set S returned by the distinguisher. However, this does not mean that this correction must necessarily be implemented as an additional quantum operation by Bob. We use this protocol within Protocol 2 to build a resource state for the UBQC protocol, which already requires Alice to send measurement angles to Bob. Alice can merge the correction with these measurement angles so that both are applied simultaneously as a single operation. Therefore, this correction does not imply an additional classical communication step, nor an additional operation by Bob, if Protocol 3 is used together with UBQC."
    },
    {
        "id_": "d40a98eb-9794-4ce8-90b3-1069cfc12de3",
        "text": "# Protocol security.\n\nThe privacy amplification protocol presented above constructs the Blind Graph State Extender Resource 1, with a security error which decreases exponentially in the number of pulses n sent by Alice. This analysis holds in the lossless regime, assuming that each laser pulse has a probability ⇁1 of applying the rotated emission operator to the spin qubit. The next section gives arguments for this assumption and discusses more realistic settings when taking losses into account. The security of our protocol is given by Theorem 5, whose proof can be found in Appendix C."
    },
    {
        "id_": "a7784807-9c02-42f4-9e7a-25954617c117",
        "text": "# Theorem 5 (AC security of Protocol 3).\n\nLet ⇁1 be the probability that the quantum emitter generates a photon after receiving a laser pulse of intensity |ω|2 and let pϱ,2 = 1 ↓ e↗|ϱ|2 ↓ |ω|2 e↗|ϱ|2 be the probability that the laser pulse contains two or more photons. Let (ω, n) be the public parameters used in Protocol 3, and let t = φ1 + pω,2n. Then Protocol 3 exp(↓νϱ n)-constructs in the Abstract Cryptography framework the Blind Graph State Extender Resource 1, for νϱ = (⇁1 ↓ pϱ,2)2 /2.\n\n18"
    },
    {
        "id_": "9487dcd1-bf12-423a-946c-d372ff53d5d3",
        "text": "# 3.3 Post-selecting on receiving all photons\n\nIt is possible also for Alice to reject the state as soon as a single photon is lost. We describe this alternative formally in Appendix D as Protocol 6, along with a correctness and security analysis.\n\nThe threshold protocol presented above will abort significantly less often than the one which requires Bob to recover all photons. This is because Protocol 3 tolerates some losses due to a photon not being emitted. On the other hand, the security bound is slightly degraded. Combined together, the threshold protocol’s security and successful completion probability both increase with the number of emitted photons, as expressed in Theorem 5. It would seem like it is therefore the superior protocol since the success probability of the post-selected protocol actually decreases exponentially with the number of photons which need to be collected.\n\nHowever this analysis holds only if we assume that (i) there are no losses after the photons have been emitted, and (ii) the emission operator correctly describes the result of the interaction between the laser pulse and the quantum emitter.\n\nIf a photonic qubit is lost after it has been generated in Protocol 3, the state is perfectly mixed from the point of view of both Alice and Bob. Discarding the state as soon as a single photon is not detected by Bob during the measurement prevents this issue and as a consequence the correctness of the output state of Protocol 6 is unaffected by losses which happen after the qubit generation procedure. This includes the case where the photon is emitted while the interaction between the laser and the quantum emitter is still taking place and is filtered out as described in Section 4.1.\n\nBoth protocols on the other hand may suffer if the laser-spin interaction deviates from the ideal emission operator described here. If for instance a photon is emitted while the laser interaction is ongoing and the laser re-excites the quantum emitter resulting in a second photon being emitted, neither protocols will count this as a loss but the end result will be a perfectly mixed state in both cases. However, if the operator instead applies a slightly different angle for some or all values of ε, this can be mitigated if the overall protocol can tolerate this noise level."
    },
    {
        "id_": "3b927bba-5797-428c-936e-21bf263c5963",
        "text": "# 3.4 Delegated quantum computation protocols with semi-classical client\n\nWe describe in this section how to build delegated quantum computation protocols with a semi-classical client. To this end we compose our bind graph RSP protocol and privacy amplification protocol with the protocols from [5] and [26] to obtain respectively BDQC and SDQC protocols."
    },
    {
        "id_": "23fc5272-ba88-4f54-a310-154ce34bd134",
        "text": "# Blind delegation from semi-classical client RSP.\n\nWe use the composition theorem from the AC framework to replace the call to the Blind Graph RSP resource in the UBQC protocol from Section C with our Protocols 2 and 3. The general composition Theorem 8 allows us to combine Theorems 9, 4 and 5 into the following result."
    },
    {
        "id_": "c9244a4b-185f-46c3-be39-d0691be88d65",
        "text": "# Theorem 6 (BDQC with semi-classical client).\n\nLet ω, ν ϱ, n be defined as in Theorem 5 and let |V| be the number of vertices in the graph supporting Alice’s desired MBQC computation. Consider the protocol obtained by replacing the blind graph state generation in the UBQC Protocol 4 (steps 1 and 2) with Protocol 2 composed with Protocol 3 with parameters (ω, n). This protocol |V| · exp(↓νϱ n)-constructs in the Abstract Cryptography framework the BDQC Resource 3."
    },
    {
        "id_": "30af6d0a-e4d3-49ff-9b65-513f08d5f149",
        "text": "# Testing the server’s honesty with semi-classical light\n\nThere are two challenges when trying to use our semi-classical client technique together with protocols for SDQC which require the client to produce states in the computational basis, such as those from [8, 50, 51].\n\nFirst of all, generating a computational basis state with the energy structure presented in Figure 4 would project the spin state to the corresponding computational basis state. This would then need to be reinitialised by the Server to continue the entanglement generation. The information of whether or not the spin needs to be reinitialised in a superposition would therefore leak whether the state produced is rotated or in the computational basis.\n\nThen, there is the issue of amplifying the security of both computational basis and rotated states using a single gadget which does not introduce new attack vectors or leak information. This has been attempted in [54] but a new attack on their scheme has been shown in [26]. Thankfully, this second work also fixes the issue by proposing a novel SDQC protocol which makes use of the generalised tests introduced in [55]. This corresponds to the protocol presented in Section 2.2.3 and more formally as Protocol 5.\n\nThe composable security of their protocol scales exponentially with the number of repetitions of the UBQC protocol, and the security of our blind graph RSP protocol degrades linearly in the number of repetitions. We again use the general composition Theorem 8 to combine Theorems 10 and 5 into the following result, yielding an SDQC protocol in which Alice only needs to send weak coherent states."
    },
    {
        "id_": "cab46ea3-7e16-4325-82ea-3b29b9214a62",
        "text": "# Theorem 7 (SDQC with semi-classical client)\n\nLet ω, ν ϱ, n be defined as in Theorem 5, let N be the number of executions of the UBQC Protocol 4 in Protocol 5 and let |V| be the number of vertices in the graph supporting Alice’s desired MBQC computation. Consider the protocol obtained by replacing the blind graph state generation step in each UBQC execution in the SDQC Protocol 5 with Protocol 2 composed with Protocol 3 with parameters (ω, n). This protocol N |V| · exp(↓νϱ n) + -S -constructs in the Abstract Cryptography framework the SDQC Resource 4, for -S exponentially decreasing in N being the security bound of the SDQC Protocol 5.\n\nFinally, as shown in [26, 55], this SDQC protocol tolerates a constant level of global honest noise, meaning that slight defects will be corrected and Alice is able to recover the correct output without aborting even if her apparatus or Bob’s have a low-enough level of noise."
    },
    {
        "id_": "e9c260bc-e3ff-45bd-9665-a35e4c5c8141",
        "text": "# 4 Fine-tuning laser intensity for correctness/security trade-off\n\nIn the previous section we have shown via Theorem 5 that, so long as the total single-photon efficiency ⇁1 is greater than the probability of receiving two or more photons p ϱ,2, we can amplify the security of blind state generation to arbitrary levels by increasing the number of photons in the GHZ gadget.\n\nThe vacuum probability of the incoming coherent pulse imposes an upper bound on= 1 ↓ e↗|ϱ|2. ⇁1 of p ϱ,1. In reality, if the average number of photons |ω|2 is not large enough, the population of the emitter will not be sufficiently inverted to achieve single-photon emission with a high efficiency and the criteria for security amplification may not be satisfied. The exact value of ⇁1 can depend on the energy-level structure of the device, the excitation scheme, and the pulse parameters. Thus, an important question is: can any practical single-photon generation schemes and parameter regimes allow for ⇁1 ∝ p ϱ,2?"
    },
    {
        "id_": "158f0fc9-fedf-4b69-9df4-d5fca94757fd",
        "text": "# 4.1 Two-level emitter\n\nIn this section, we will take a step further towards a practical implementation by discussing constraints on ⇁1 imposed by basic models for single-photon emission. In particular, we focus on idealised single-photon generation protocols (those that ensure no more than one photon is collected). Experimental considerations for possible implementation, and comparison with the state of the art, will be discussed more in the following section.\n\nDriving a two-level emitter with a laser is a common approach to produce single photons. By applying a coherent pulse with a temporal width much less than the lifetime of the emitter, the state of the emitter can be excited from the ground state |g→ to the excited state |e→ with a high fidelity, allowing spontaneous emission to produce a single photon. Such an excitation scheme can then be applied to an emitter with an additional internal degree of freedom, such as electron spin, to generate photonic graph states encoded in polarisation [21] as discussed in section 2.1.\n\nThe main challenge with using a two-level emitter is to separate the scattered single photon from the laser pulse to achieve a high degree of single-photon purity, where the probability of collecting more than one photon is very small. This is done by using excitation schemes where the scattered single photon and laser pulse can be distinguished by a degree of freedom such as polarisation, frequency, or spatial mode. Unfortunately, achieving a high single-photon e”ciency using weak excitation pulses necessarily requires a high degree of light-matter coupling, which implies that these degrees of freedom should be as close as possible to improve the mode-matching between the laser pulse and the emitter. Thus, using a scheme based on a two-level emitter immediately introduces a trade-o! between the single-photon e”ciency and fidelity for a fixed number of photons in the laser pulse.\n\nTo get an idea of the practical limit when using a two-level emitter, and to see how well it could perform compared to the upper bound, we choose to distinguish the single photon from the laser pulse using the temporal degree of freedom. This approach is only practical when using very weak excitation pulses, since otherwise any small imperfections in the temporal shape of the laser pulse would very quickly overwhelm the single photon signal and reduce the single-photon purity. This filtering could be accomplished using a fast optical switch or by using detectors with a su”ciently fast gate or high temporal resolution.\n\nThe text-book model for exciting a two-level emitter treats the laser using a semi-classical approximation, where it is assumed that the state of the pulse remains in a coherent state throughout the entire light-matter interaction so that only the quantum dynamics of the emitter must be considered. However, when dealing with weak states of light, measuring a single photon scattered o! the emitter can induce non-negligible quantum fluctuations in the laser pulse that may alter the quantum dynamics of the excitation process. Luckily, if we temporally filter only single photons that were emitted after the pulse has completely finished interacting with the emitter, causality ensures that the semi-classical approximation will provide an accurate analytic solution for the single-photon e”ciency ⇁1.\n\nA basic model for a driven two-level emitter using the semi-classical approximation is described by the quantum optical master equation [56] of the form d↽(t)/dt = L(t)↽(t) that governs the evolution of the emitter density operator ↽(t). The generator superoperator is L(t) = ↓iH(t)+▷D ↼ , where H↽ = [H, ↽] is the action of applying the commutator with the emitter Hamiltonian H, ▷ is the emitter decay rate, and D ↼ ↽ = ◁↽◁ † ↓ ◁ † ◁↽/2 ↓ ↽◁ † ◁/2"
    },
    {
        "id_": "4daf2135-d806-4b1e-a194-4d54a5b76c2f",
        "text": "# Figure 9: A resonantly driven two-level emitter for producing single photons from a weak coherent state."
    },
    {
        "id_": "88a0fcee-d91b-41ad-8db7-188e5e21f72a",
        "text": "# (a) Excitation pulse"
    },
    {
        "id_": "88f9cf25-6ba4-4231-a74b-91523c34ebdf",
        "text": "# (b) Two-level emitter"
    },
    {
        "id_": "149199a2-7b52-4294-a94f-2d90a270631b",
        "text": "# (c) Time-filtered single photon\n\n|Rabi freq.|Intensity|Time|\n|---|---|---|\n|3.0|1.0|0.00|\n|2.5|0.6|1|\n|2.0|0.4|2|\n|1.5|0.2|3|\n|1.0|0.0|4|\n|0.5|0.0|5|\n|0.0|0.0|6|\n\nThe square excitation pulse with pulse area # and width 0 = #2 /(4▷|ω|2 ) in a coherent state with average photon number |ω|2. A two-level emitter driven by the excitation pulse Rabi frequency $(t) and decaying with rate ▷. The emission intensity quantified by the occupation probability of the two-level emitter, highlighting the excitation and decay steps. By collecting emission after the pulse has finished interacting with the emitter, the emitted light is in a single photon state.\n\nis the dissipation superoperator with ◁ = |g→ ↑e| being the emitter lower operator. The Emission intensity Hamiltonian is H(t) = $(t)◁ x /2, where ◁ x = ◁ + ◁ † is the Pauli X operator and $(t) is the excitation pulse Rabi frequency.\n\nTo consider the ideal limit for this scheme, where all multi-photon components are fully suppressed, we define $(t) to be a perfect square input pulse beginning at t = 0 and ending at t = 0 as illustrated in Figure 9(a). That is, we define the Rabi frequency to be:\n\n$(t) = { 0, 0 ⇔ t ⇔ 0; 0, t > 0 }\n\nFor ideal light-matter coupling, the Rabi frequency is related to the average number of photons |ω|2 by |ω|2 = #2 /4▷0, where # = is the pulse area. After the pulse excites the two-level emitter, as illustrated in Figure 9(b), we collect only the light found in the output mode for when t > 0 (see Figure 9(c)).\n\nSince for t ∝ 0, all multi-photon components will vanish, the single-photon emission probability ⇁1 is equal to the occupation probability of the emitter excited state at time t = 0. This can be solved in a straightforward way by taking the matrix exponential of the generator ⇁1 = ↑e| e↽ L |g→, resulting in:\n\n⇁1 = 1 ↓ ▷ 2 + 2$ 2\n\nwhere $ = $(0 ) = 4▷|ω|2 /# and $↔ = (▷/4)2 + $ 2.\n\nTo be sure that the two-level emitter can allow for security amplification, we must check if the probability of generating a single photon ⇁1 is greater than the probability of receiving two or more photons p ϱ,2. That is, the performance of a generation scheme is determined by the maximum value of ⇁1 such that ⇁1 ↓ p ϱ,2 is positive. = sin(#/2)2.\n\nIn the limit ▷ ′ $, where |ω|2 ∞ 1, the expression for ⇁1 reduces to ⇁1 as expected from the pulse area theorem [57]. In this limit, a ϱ pulse corresponding to:\n\nFor the correctness of our protocol we assume that no photon is emitted for t ↗ ε. If a photon is emitted during that interval and filtered out, it will always result in a perfectly mixed state at the output. However, the security is not impacted by this filtering since it will at most reduce the information available to Bob."
    },
    {
        "id_": "66923cda-e6de-4602-b67a-157f3b1ec05f",
        "text": "# 4.2 Saturating the upper-bound via alternative energy level structures\n\nThe scheme analysed in the previous section gives a concrete idea of how to satisfy the criteria for security amplification using an excitation scheme that can be directly applied to protocols for deterministic graph state generation, but it is not the only approach to generating a single photon from a weak coherent state nor is it the most efficient. It may be possible to improve ⇁1 by using a cavity to control the light-matter coupling or by altering the shape of the coherent pulse. But it is not easy to see how to attain the upper bound ⇁1 = p 1,ϱ using just a two-level emitter, or that it is even possible in general. Interestingly, it is possible to reach the upper bound by increasing the complexity of the emitter energy level structure.\n\nThe upper bound p 1,ϱ can be reached by considering a system with just one additional ground state |s→ that is detuned from |g→, so that we have a three-level % type energy level structure (see Figure 11(a)). If the % system is initially in the ground state |g→, a coherent pulse can be used to excite the system to state |e→. As soon as a single photon is emitted by the system due to the decay of |e→ to |s→, the system is no longer coupled by the excitation pulse and thus cannot be re-excited. Therefore, by filtering the emission in frequency, the"
    },
    {
        "id_": "ccb04a59-9cba-4834-aa58-0e926c325d67",
        "text": "# 4.3 Paths towards experimental implementations\n\nThe excitation of quantum dots using weak laser pulses has already been realised in [58]. They demonstrated that a coherent state with an average of 3.8 (8.6) photons was able to invert the transition of a quantum dot exciton with a 62% (81%) probability. Comparing these values to the predictions from Figure 10, Section 4.1, indicates that these inversion probabilities are not yet sufficient to allow for security amplification, but the trend is favourable and shows that proof-of-concept experiments may be feasible with current technology. It is important to note however that in Ref. [58] they use resonant excitation to maximise light-matter coupling and thus require polarisation filtering to separate the single photons from the excitation pulse. This pulse-filtering method is not compatible with the spin-polarisation entanglement which we use to generate graph states. Hence further developments and experimental proposals are required.\n\nThe Lindner-Rudolph protocol for generating spin-polarisation entanglement using quantum dots has been experimentally demonstrated in Refs. [23–25, 61]. For example, in Ref. [23], three horizontally-polarised laser pulses are used to generate a spin-photon-photon linear cluster state. A similar protocol and setup, adding only a controlled polarisation to the second pulse, can be used to perform a proof-of-concept experiment to confirm that the emission can indeed be described by the operator E qe (ε).\n\nMulti-photon emission probability can be fully suppressed without sacrificing the single-photon probability. This allows for moving arbitrarily close to the upper bound p 1,ϱ by simply increasing the quality of mode matching between the excitation pulse and the excitation transition, and also by engineering the decay of the system so that the transition |e→ to |s→ is much more likely than the transition |e→ to |g→.\n\nAlthough the % scheme can be brought arbitrarily close to the upper bound p 1,ϱ allowing for security amplification while asymptotically reaching perfect efficiency ⇁1 ≃ 1, it is more difficult to work with and control physical systems that allows for two such % configurations, which would be necessary to deterministically generate photonic graph states (see Figure 11(b)). The excitation scheme also favours temporally long pulses, which may negatively impact computational rate. However, this level structure has already been used to generate entangled photonic graph states using a single rubidium atom in an optical cavity [25]."
    },
    {
        "id_": "d107ddf1-714b-4d2f-a59c-3f68fdbc8fce",
        "text": "this technique uses high-energy o!-resonant excitation pulses [62], meaning that the laser power is too high to amplify security and recover blindness.\n\nMany approaches could be used to reduce excitation power while still producing entangled states of light. As demonstrated theoretically in Section 4.1, a resonant excitation with a fast laser pulse and temporal filtering can, in principle, allow for security amplification. Furthermore, in the schemes described above, the excitation pulse must pass through a highly-reflective cavity mirror before interacting with the quantum emitter. Using multi-frequency excitation pulses as in the SUPER scheme [63, 64], or exciting the source along a spatial axis which is di!erent from the predominant emission direction, could by-pass this limitation and thus reduce the required pump power. This second approach would also allow for spatial filtering. Finally, as discussed in Section 4.2, emitters with a more complex energy level structure would open new avenues to engineer energetically e”cient deterministic entanglement generation schemes."
    },
    {
        "id_": "90b54e6d-4c02-402d-9ff5-ce388bf90da2",
        "text": "# 5 Conclusion and future work\n\nIn this paper, we presented a protocol that greatly reduces the technological requirements for performing blind and secure delegated quantum computations. Not only does the client no longer require a single qubit source or measurement device, but the server does not need to perform complex operations such as measuring the photon number without disturbing the photons’ polarisation, or performing photon-photon entangling gates. All that the server requires is interacting quantum emitters which can generate spin-photon entanglement. Our protocol is information-theoretically secure, as proven in the composable security framework of Abstract Cryptography.\n\nHowever, the security analysis relies on very pessimistic assumptions. In particular, we assume that all information about an angle is leaked so long as a laser pulse contains more than one photon. This requires the server to isolate the photons contained in a pulse and manipulate them individually, which is challenging in itself, but it also overestimates the amount of information that the server can gain from these states. Relaxing this assumption or redefining security in a less drastic way (in terms of distinguishing advantage, or including a more comprehensive study of leakage) would yield an improved security bound. Another path would be to randomise the states even more.\n\nThen, in the current work, we use 2D graph structures which are su”cient for universal blind quantum computing. Expanding these results to 3D graphs which also enables fault-tolerance would be an interesting direction to handle both photon losses and the server’s honest processing errors [65].\n\nFinally, our analysis in Section 4.2 leaves a very interesting open question: which physical systems and practical excitation schemes can allow for energetically e”cient deterministic photonic graph state generation to optimise security amplification? Although a definitive answer to this question goes beyond the scope of this work, we believe that frameworks such as microscopic quantum energetics [66–68] can be readily applied to solve this problem."
    }
]